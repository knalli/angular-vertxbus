{"version":3,"sources":["webpack:///webpack/universalModuleDefinition","webpack:///webpack/bootstrap f6b51b6c756bbbfb67b0","webpack:///./src/index.js","webpack:///./src/module.js","webpack:///./src/config.js","webpack:///./src/lib/VertxEventBusWrapperProvider.js","webpack:///./src/lib/adapter/EventBusAdapter.js","webpack:///./src/lib/adapter/BaseAdapter.js","webpack:///./src/lib/support/ConnectionConfigHolder.js","webpack:///./src/lib/adapter/NoopAdapter.js","webpack:///./src/lib/VertxEventBusServiceProvider.js","webpack:///./src/lib/service/delegate/EventBusDelegate.js","webpack:///./src/lib/support/Queue.js","webpack:///./src/lib/support/SimpleMap.js","webpack:///./src/lib/service/delegate/BaseDelegate.js","webpack:///./src/lib/service/delegate/NoopDelegate.js","webpack:///./src/lib/service/Delegator.js"],"names":[],"mappings":"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","file":"dist/angular-vertxbus.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory(require(\"vertx-eventbus\"));\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([\"vertx-eventbus\"], factory);\n\telse {\n\t\tvar a = typeof exports === 'object' ? factory(require(\"vertx-eventbus\")) : factory(root[\"EventBus\"]);\n\t\tfor(var i in a) (typeof exports === 'object' ? exports : root)[i] = a[i];\n\t}\n})(this, function(__WEBPACK_EXTERNAL_MODULE_8__) {\nreturn \n\n\n/** WEBPACK FOOTER **\n ** webpack/universalModuleDefinition\n **/"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n/** WEBPACK FOOTER **\n ** webpack/bootstrap f6b51b6c756bbbfb67b0\n **/","import moduleName from './module';\n\nexport default moduleName;\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/index.js\n **/","import {moduleName} from './config';\n\nimport VertxEventBusWrapperProvider from './lib/VertxEventBusWrapperProvider';\nimport VertxEventBusServiceProvider from './lib/VertxEventBusServiceProvider';\n\n/**\n * @ngdoc overview\n * @module knalli.angular-vertxbus\n * @name knalli.angular-vertxbus\n * @description\n *\n * Client side library using VertX Event Bus as an Angular Service module\n *\n * You have to define the module dependency, this module is named `knalli.angular-vertxbus`.\n *\n * <pre>\n *   angular.module('app', ['knalli.angular-vertxbus'])\n *     .controller('MyCtrl', function(vertxEventBus, vertxEventBusService) {\n *\n *       // using the EventBus directly\n *       vertxEventBus.send('my.address', {data: 123}, function (reply) {\n *         // your reply comes here\n *       });\n *\n *       // using the service\n *       vertxEventBusService.send('my.address', {data: 123}, {timeout: 500})\n *         .then(function (reply) {\n *           // your reply comes here\n *         })\n *         .catch(function (err) {\n *           // something went wrong, no connection, no login, timed out, or so\n *         });\n *     });\n * </pre>\n *\n * The module itself provides following components:\n * - {@link knalli.angular-vertxbus.vertxEventBus vertxEventBus}: a low level wrapper around `vertx.EventBus`\n * - {@link knalli.angular-vertxbus.vertxEventBusService vertxEventBusService}: a high level service around the wrapper\n *\n * While the wrapper only provides one single instance (even on reconnects), the service supports automatically\n * reconnect management, authorization and a clean promise based api.\n *\n * If you are looking for a low integration of `vertxbus.EventBus` as an AngularJS component, the wrapper will be your\n * choice. The only difference (and requirement for the wrapper actually) is how it will manage and replace the\n * underlying instance of the current `vertx.EventBus`.\n *\n * However, if you are looking for a simple, clean and promised based high api, the service is much better you.\n */\nexport default angular\n\n  .module(moduleName, ['ng'])\n\n  .provider('vertxEventBus', VertxEventBusWrapperProvider)\n  .provider('vertxEventBusService', VertxEventBusServiceProvider)\n\n  .name;\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/module.js\n **/","const moduleName = 'knalli.angular-vertxbus';\n\nexport {moduleName};\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/config.js\n **/","import EventBusAdapter from './adapter/EventBusAdapter';\nimport NoopAdapter from './adapter/NoopAdapter';\nimport ConnectionConfigHolder from './support/ConnectionConfigHolder';\n\nimport EventBus from 'vertx-eventbus';\n\n/**\n * @ngdoc service\n * @module knalli.angular-vertxbus\n * @name knalli.angular-vertxbus.vertxEventBusProvider\n * @description\n * An AngularJS wrapper for projects using the VertX Event Bus\n */\n\nconst DEFAULTS = {\n  enabled : true,\n  debugEnabled : false,\n  initialConnectEnabled : true,\n  urlServer : `${location.protocol}//${location.hostname}` + ((() => {\n    if (location.port) {\n      return `:${location.port}`;\n    }\n  })() || ''),\n  urlPath : '/eventbus',\n  reconnectEnabled : true,\n  sockjsReconnectInterval : 10000,\n  sockjsOptions : {}\n};\n\nlet VertxEventBusWrapperProvider = function () {\n\n  // options (globally, application-wide)\n  var options = angular.extend({}, DEFAULTS);\n\n  /**\n   * @ngdoc method\n   * @module knalli.angular-vertxbus\n   * @methodOf knalli.angular-vertxbus.vertxEventBusProvider\n   * @name .#enable\n   *\n   * @description\n   * Enables or disables the service. This setup is immutable.\n   *\n   * @param {boolean} [value=true] service is enabled on startup\n   * @returns {object} this\n   */\n  this.enable = (value = DEFAULTS.enabled) => {\n    options.enabled = (value === true);\n    return this;\n  };\n\n  /**\n   * @ngdoc method\n   * @module knalli.angular-vertxbus\n   * @methodOf knalli.angular-vertxbus.vertxEventBusProvider\n   * @name .#disableAutoConnect\n   *\n   * @description\n   * Disables the auto connection feature.\n   *\n   * This feature will be only available if `enable == true`.\n   *\n   * @param {boolean} [value=true] auto connect on startup\n   * @returns {object} this\n   */\n  this.disableAutoConnect = () => {\n    options.initialConnectEnabled = false;\n    return this;\n  };\n\n  /**\n   * @ngdoc method\n   * @module knalli.angular-vertxbus\n   * @methodOf knalli.angular-vertxbus.vertxEventBusProvider\n   * @name .#useDebug\n   *\n   * @description\n   * Enables a verbose mode in which certain events will be logged to `$log`.\n   *\n   * @param {boolean} [value=false] verbose mode (using `$log`)\n   * @returns {object} this\n   */\n  this.useDebug = (value = DEFAULTS.debugEnabled) => {\n    options.debugEnabled = (value === true);\n    return this;\n  };\n\n  /**\n   * @ngdoc method\n   * @module knalli.angular-vertxbus\n   * @methodOf knalli.angular-vertxbus.vertxEventBusProvider\n   * @name .#useUrlServer\n   *\n   * @description\n   * Overrides the url part \"server\" for connecting. The default is based on\n   * - `location.protocol`\n   * - `location.hostname`\n   * - `location.port`\n   *\n   * i.e. `http://domain.tld` or `http://domain.tld:port`\n   *\n   * @param {boolean} [value=$computed] server to connect (default based on `location.protocol`, `location.hostname` and `location.port`)\n   * @returns {object} this\n   */\n  this.useUrlServer = (value = DEFAULTS.urlServer) => {\n    options.urlServer = value;\n    return this;\n  };\n\n  /**\n   * @ngdoc method\n   * @module knalli.angular-vertxbus\n   * @methodOf knalli.angular-vertxbus.vertxEventBusProvider\n   * @name .#useUrlPath\n   *\n   * @description\n   * Overrides the url part \"path\" for connection.\n   *\n   * @param {boolean} [value='/eventbus'] path to connect\n   * @returns {object} this\n   */\n  this.useUrlPath = (value = DEFAULTS.urlPath) => {\n    options.urlPath = value;\n    return this;\n  };\n\n  /**\n   * @ngdoc method\n   * @module knalli.angular-vertxbus\n   * @methodOf knalli.angular-vertxbus.vertxEventBusProvider\n   * @name .#useReconnect\n   *\n   * @description\n   * Enables or disables the automatic reconnect handling.\n   *\n   * @param {boolean} [value=true] if a disconnect was being noted, a reconnect will be enforced automatically\n   * @returns {object} this\n   */\n  this.useReconnect = (value = DEFAULTS.reconnectEnabled) => {\n    options.reconnectEnabled = value;\n    return this;\n  };\n\n  /**\n   * @ngdoc method\n   * @module knalli.angular-vertxbus\n   * @methodOf knalli.angular-vertxbus.vertxEventBusProvider\n   * @name .#useSockJsReconnectInterval\n   *\n   * @description\n   * Overrides the timeout for reconnecting after a disconnect was found.\n   *\n   * @param {boolean} [value=10000] time between a disconnect and the next try to reconnect (in ms)\n   * @returns {object} this\n   */\n  this.useSockJsReconnectInterval = (value = DEFAULTS.sockjsReconnectInterval) => {\n    options.sockjsReconnectInterval = value;\n    return this;\n  };\n\n  /**\n   * @ngdoc method\n   * @module knalli.angular-vertxbus\n   * @methodOf knalli.angular-vertxbus.vertxEventBusProvider\n   * @name .#useSockJsOptions\n   *\n   * @description\n   * Sets additional params for the `SockJS` instance.\n   *\n   * Internally, it will be applied (as `options`) like `new SockJS(url, undefined, options)`.\n   *\n   * @param {boolean} [value={}]  optional params for raw SockJS options\n   * @returns {object} this\n   */\n  this.useSockJsOptions = (value = DEFAULTS.sockjsOptions) => {\n    options.sockjsOptions = value;\n    return this;\n  };\n\n  /**\n   * @ngdoc service\n   * @module knalli.angular-vertxbus\n   * @name knalli.angular-vertxbus.vertxEventBus\n   * @description\n   * A stub representing the Vert.x EventBus (core functionality)\n   *\n   * Because the Event Bus cannot handle a reconnect (because of the underlaying SockJS), a\n   * new instance of the bus have to be created.\n   * This stub ensures only one object holding the current active instance of the bus.\n   *\n   * The stub supports theses Vert.x Event Bus APIs:\n   *  - {@link knalli.angular-vertxbus.vertxEventBus#methods_close close()}\n   *  - {@link knalli.angular-vertxbus.vertxEventBus#methods_send send(address, message, handler)}\n   *  - {@link knalli.angular-vertxbus.vertxEventBus#methods_publish publish(address, message)}\n   *  - {@link knalli.angular-vertxbus.vertxEventBus#methods_registerHandler registerHandler(adress, handler)}\n   *  - {@link knalli.angular-vertxbus.vertxEventBus#methods_unregisterHandler unregisterHandler(address, handler)}\n   *  - {@link knalli.angular-vertxbus.vertxEventBus#methods_readyState readyState()}\n   *\n   * Furthermore, the stub supports theses extra APIs:\n   *  - {@link knalli.angular-vertxbus.vertxEventBus#methods_reconnect reconnect()}\n   *\n   * @requires $timeout\n   * @requires $log\n   */\n  /* @ngInject */\n  this.$get = ($timeout, $log, $q) => {\n    // Current options (merged defaults with application-wide settings)\n    let instanceOptions = angular.extend({}, DEFAULTS, options);\n    if (instanceOptions.enabled && EventBus) {\n      if (instanceOptions.debugEnabled) {\n        $log.debug('[Vert.x EB Stub] Enabled');\n      }\n\n      // aggregate server connection params\n      instanceOptions.connectionConfig = new ConnectionConfigHolder({\n        urlServer : instanceOptions.urlServer,\n        urlPath : instanceOptions.urlPath\n      });\n      delete instanceOptions.urlServer;\n      delete instanceOptions.urlPath;\n\n      return new EventBusAdapter(EventBus, $timeout, $log, $q, instanceOptions);\n    } else {\n      if (instanceOptions.debugEnabled) {\n        $log.debug('[Vert.x EB Stub] Disabled');\n      }\n      return new NoopAdapter(EventBus, $q);\n    }\n  };\n\n};\n\nexport default VertxEventBusWrapperProvider;\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/lib/VertxEventBusWrapperProvider.js\n **/","import {moduleName} from '../../config.js';\n\nimport BaseAdapter from './BaseAdapter';\nimport ConnectionConfigHolder from './../support/ConnectionConfigHolder';\n\n/**\n * @ngdoc service\n * @module global\n * @name global.EventBus\n *\n * @description\n * This is the interface of `EventBus`. It is not included.\n */\n\n/**\n * @ngdoc method\n * @module global\n * @methodOf global.EventBus\n * @name .#close\n */\n\n/**\n * @ngdoc method\n * @module global\n * @methodOf global.EventBus\n * @name .#send\n *\n * @param {string} address target address\n * @param {object} message payload message\n * @param {object=} headers headers\n * @param {function=} replyHandler optional callback\n * @param {function=} failureHandler optional callback\n */\n\n/**\n * @ngdoc method\n * @module global\n * @methodOf global.EventBus\n * @name .#publish\n *\n * @param {string} address target address\n * @param {object} message payload message\n * @param {object=} headers headers\n */\n\n/**\n * @ngdoc method\n * @module global\n * @methodOf global.EventBus\n * @name .#registerHandler\n *\n * @param {string} address target address\n * @param {function} handler callback handler\n * @param {object=} headers headers\n */\n\n/**\n * @ngdoc method\n * @module global\n * @methodOf global.EventBus\n * @name .#unregisterHandler\n *\n * @param {string} address target address\n * @param {function} handler callback handler to be removed\n * @param {object=} headers headers\n */\n\n/**\n * @ngdoc property\n * @module global\n * @propertyOf global.EventBus\n * @name .#onopen\n * @description\n * Defines the callback called on opening the connection.\n */\n\n/**\n * @ngdoc property\n * @module global\n * @propertyOf global.EventBus\n * @name .#onclose\n * @description\n * Defines the callback called on closing the connection.\n */\n\n/**\n * @ngdoc property\n * @module global\n * @propertyOf global.EventBus\n * @name .#onerror\n * @description\n * Defines the callback called on any error.\n */\n\nexport default class EventBusAdapter extends BaseAdapter {\n\n  constructor(EventBus, $timeout, $log, $q, {\n    enabled,\n    debugEnabled,\n    initialConnectEnabled,\n    connectionConfig,\n    reconnectEnabled,\n    sockjsReconnectInterval,\n    sockjsOptions\n    }) {\n    super($q);\n    // actual EventBus type\n    this.EventBus = EventBus;\n    this.$timeout = $timeout;\n    this.$log = $log;\n    this.$q = $q;\n    this.options = {\n      enabled,\n      debugEnabled,\n      initialConnectEnabled,\n      connectionConfig,\n      reconnectEnabled,\n      sockjsReconnectInterval,\n      sockjsOptions\n    };\n    this.disconnectTimeoutEnabled = true;\n    this.applyDefaultHeaders();\n    if (initialConnectEnabled) {\n      // asap create connection\n      this.connect();\n    }\n  }\n\n  /**\n   * @ngdoc method\n   * @module knalli.angular-vertxbus\n   * @methodOf knalli.angular-vertxbus.vertxEventBus\n   * @name .#configureConnect\n   *\n   * @description\n   * Reconfigure the connection details.\n   *\n   * @param {string} urlServer see {@link knalli.angular-vertxbus.vertxEventBusProvider#methods_useUrlServer vertxEventBusProvider.useUrlServer()}\n   * @param {string} [urlPath=/eventbus] see {@link knalli.angular-vertxbus.vertxEventBusProvider#methods_useUrlPath vertxEventBusProvider.useUrlPath()}\n   */\n  configureConnection(urlServer, urlPath = '/eventbus') {\n    this.options.connectionConfig = new ConnectionConfigHolder({urlServer, urlPath});\n    return this;\n  }\n\n  connect() {\n    // connect promise\n    let deferred = this.$q.defer();\n    // currently valid url\n    let url = `${this.options.connectionConfig.urlServer}${this.options.connectionConfig.urlPath}`;\n    if (this.options.debugEnabled) {\n      this.$log.debug(`[Vert.x EB Stub] Enabled: connecting '${url}'`);\n    }\n    // Because we have rebuild an EventBus object (because it have to rebuild a SockJS object)\n    // we must wrap the object. Therefore, we have to mimic the behavior of onopen and onclose each time.\n    this.instance = new this.EventBus(url, this.options.sockjsOptions);\n    this.instance.onopen = () => {\n      if (this.options.debugEnabled) {\n        this.$log.debug('[Vert.x EB Stub] Connected');\n      }\n      if (angular.isFunction(this.onopen)) {\n        this.onopen();\n      }\n      deferred.resolve();\n    };\n    // instance onClose handler\n    this.instance.onclose = () => {\n      if (this.options.debugEnabled) {\n        this.$log.debug(`[Vert.x EB Stub] Reconnect in ${this.options.sockjsReconnectInterval}ms`);\n      }\n      if (angular.isFunction(this.onclose)) {\n        this.onclose();\n      }\n      this.instance = undefined;\n\n      if (!this.disconnectTimeoutEnabled) {\n        // reconnect required asap\n        if (this.options.debugEnabled) {\n          this.$log.debug('[Vert.x EB Stub] Reconnect immediately');\n        }\n        this.disconnectTimeoutEnabled = true;\n        this.connect();\n      } else if (this.options.reconnectEnabled) {\n        // automatic reconnect after timeout\n        if (this.options.debugEnabled) {\n          this.$log.debug(`[Vert.x EB Stub] Reconnect in ${this.options.sockjsReconnectInterval}ms`);\n        }\n        this.$timeout((() => this.connect()), this.options.sockjsReconnectInterval);\n      }\n    };\n    // instance onError handler\n    this.instance.onerror = (message) => {\n      if (angular.isFunction(this.onerror)) {\n        this.onerror(message);\n      }\n    };\n    return deferred.promise;\n  }\n\n  /**\n   * @ngdoc method\n   * @module knalli.angular-vertxbus\n   * @methodOf knalli.angular-vertxbus.vertxEventBus\n   * @name .#reconnect\n   *\n   * @description\n   * Reconnects the underlying connection.\n   *\n   * Unless a connection is open, it will connect using a new one.\n   *\n   * If a connection is already open, it will close this one and opens a new one. If `immediately` is `true`, the\n   * default timeout for reconnect will be skipped.\n   *\n   * @param {boolean} [immediately=false] optionally enforce a reconnect asap instead of using the timeout\n   */\n  reconnect(immediately = false) {\n    if (this.instance && this.instance.state === this.EventBus.OPEN) {\n      if (immediately) {\n        this.disconnectTimeoutEnabled = false;\n      }\n      this.instance.close();\n    } else {\n      this.connect();\n    }\n  }\n\n  /**\n   * @ngdoc method\n   * @module knalli.angular-vertxbus\n   * @methodOf knalli.angular-vertxbus.vertxEventBus\n   * @name .#close\n   *\n   * @description\n   * Closes the underlying connection.\n   *\n   * Note: If automatic reconnection is active, a new connection will be established after the {@link knalli.angular-vertxbus.vertxEventBusProvider#methods_useReconnect reconnect timeout}.\n   *\n   * See also:\n   * - {@link EventBus#methods_close EventBus.close()}\n   */\n  close() {\n    if (this.instance) {\n      this.instance.close();\n    }\n  }\n\n  /**\n   * @ngdoc method\n   * @module knalli.angular-vertxbus\n   * @methodOf knalli.angular-vertxbus.vertxEventBus\n   * @name .#send\n   *\n   * @description\n   * Sends a message\n   *\n   * See also:\n   * - {@link global.EventBus#methods_send EventBus.send()}\n   *\n   * @param {string} address target address\n   * @param {object} message payload message\n   * @param {object} headers optional headers\n   * @param {function=} replyHandler optional callback\n   */\n  send(address, message, headers, replyHandler) {\n    if (this.instance) {\n      const mergedHeaders = this.getMergedHeaders(headers);\n      this.instance.send(address, message, mergedHeaders, replyHandler);\n    }\n  }\n\n  /**\n   * @ngdoc method\n   * @module knalli.angular-vertxbus\n   * @methodOf knalli.angular-vertxbus.vertxEventBus\n   * @name .#publish\n   *\n   * @description\n   * Publishes a message\n   *\n   * See also:\n   * - {@link global.EventBus#methods_publish EventBus.publish()}\n   *\n   * @param {string} address target address\n   * @param {object} message payload message\n   * @param {object=} headers optional headers\n   */\n  publish(address, message, headers) {\n    if (this.instance) {\n      const mergedHeaders = this.getMergedHeaders(headers);\n      this.instance.publish(address, message, mergedHeaders);\n    }\n  }\n\n  /**\n   * @ngdoc method\n   * @module knalli.angular-vertxbus\n   * @methodOf knalli.angular-vertxbus.vertxEventBus\n   * @name .#registerHandler\n   *\n   * @description\n   * Registers a listener\n   *\n   * See also:\n   * - {@link global.EventBus#methods_registerHandler EventBus.registerHandler()}\n   *\n   * @param {string} address target address\n   * @param {object=} headers optional headers\n   * @param {function} handler callback handler\n   */\n  registerHandler(address, headers, handler) {\n    if (this.instance) {\n      if (angular.isFunction(headers) && !handler) {\n        handler = headers;\n        headers = undefined;\n      }\n      const mergedHeaders = this.getMergedHeaders(headers);\n      this.instance.registerHandler(address, mergedHeaders, handler);\n      // and return the deregister callback\n      let deconstructor = () => {\n        this.unregisterHandler(address, mergedHeaders, handler);\n      };\n      deconstructor.displayName = `${moduleName}.wrapper.eventbus.registerHandler.deconstructor`;\n      return deconstructor;\n    }\n  }\n\n  /**\n   * @ngdoc method\n   * @module knalli.angular-vertxbus\n   * @methodOf knalli.angular-vertxbus.vertxEventBus\n   * @name .#unregisterHandler\n   *\n   * @description\n   * Removes a registered a listener\n   *\n   * See also:\n   * - {@link global.EventBus#methods_unregisterHandler EventBus.unregisterHandler()}\n   *\n   * @param {string} address target address\n   * @param {object=} headers optional headers\n   * @param {function} handler callback handler to be removed\n   */\n  unregisterHandler(address, headers, handler) {\n    if (this.instance && this.instance.state === this.EventBus.OPEN) {\n      if (angular.isFunction(headers) && !handler) {\n        handler = headers;\n        headers = undefined;\n      }\n      const mergedHeaders = this.getMergedHeaders(headers);\n      this.instance.unregisterHandler(address, mergedHeaders, handler);\n    }\n  }\n\n  /**\n   * @ngdoc method\n   * @module knalli.angular-vertxbus\n   * @methodOf knalli.angular-vertxbus.vertxEventBus\n   * @name .#readyState\n   *\n   * @description\n   * Returns the current connection state\n   *\n   * @returns {number} value of vertx-eventbus connection states\n   */\n  readyState() {\n    if (this.instance) {\n      return this.instance.state;\n    } else {\n      return this.EventBus.CLOSED;\n    }\n  }\n\n  get state() {\n    return this.readyState();\n  }\n\n  // private\n  getOptions() {\n    // clone options\n    return angular.extend({}, this.options);\n  }\n\n}\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/lib/adapter/EventBusAdapter.js\n **/","export default class BaseAdapter {\n\n  constructor($q) {\n    this.$q = $q;\n  }\n\n  configureConnection() {\n  }\n\n  connect() {\n    return this.$q.reject();\n  }\n\n  reconnect() {\n  }\n\n  close() {\n  }\n\n  send() {\n  }\n\n  publish() {\n  }\n\n  registerHandler() {\n  }\n\n  unregisterHandler() {\n  }\n\n  readyState() {\n  }\n\n  getOptions() {\n    return {};\n  }\n\n  // empty: can be overriden by externals\n  onopen() {\n  }\n\n  // empty: can be overriden by externals\n  onclose() {\n  }\n\n  // private\n  getDefaultHeaders() {\n    return this.defaultHeaders;\n  }\n\n  /**\n   * @ngdoc method\n   * @module knalli.angular-vertxbus\n   * @methodOf knalli.angular-vertxbus.vertxEventBus\n   * @name .#applyDefaultHeaders\n   *\n   * @description\n   * Stores the given default headers\n   *\n   * @param {object} headers additional standard headers\n   */\n  applyDefaultHeaders(headers = {}) {\n    this.defaultHeaders = angular.extend({}, headers);\n  }\n\n  // private\n  getMergedHeaders(headers = {}) {\n    return angular.extend({}, this.defaultHeaders, headers);\n  }\n\n}\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/lib/adapter/BaseAdapter.js\n **/","export default class ConnectionConfigHolder {\n\n  constructor({urlServer, urlPath}) {\n    this._urlServer = urlServer;\n    this._urlPath = urlPath;\n  }\n\n  get urlServer() {\n    return this._urlServer;\n  }\n\n  get urlPath() {\n    return this._urlPath;\n  }\n\n}\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/lib/support/ConnectionConfigHolder.js\n **/","import BaseAdapter from './BaseAdapter';\n\nexport default class NoopAdapter extends BaseAdapter {\n\n  constructor(EventBus, $q) {\n    super($q);\n    // actual EventBus type\n    this.EventBus = EventBus;\n  }\n\n}\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/lib/adapter/NoopAdapter.js\n **/","import EventBusDelegate from './service/delegate/EventBusDelegate';\nimport NoopDelegate from './service/delegate/NoopDelegate';\nimport Delegator from './service/Delegator';\n\n/**\n * @ngdoc service\n * @module knalli.angular-vertxbus\n * @name knalli.angular-vertxbus.vertxEventBusServiceProvider\n * @description\n * This is the configuration provider for {@link knalli.angular-vertxbus.vertxEventBusService}.\n */\n\nconst DEFAULTS = {\n  enabled : true,\n  debugEnabled : false,\n  authRequired : false,\n  prefix : 'vertx-eventbus.',\n  sockjsStateInterval : 10000,\n  messageBuffer : 10000\n};\n\nlet VertxEventBusServiceProvider = function () {\n\n  // options (globally, application-wide)\n  var options = angular.extend({}, DEFAULTS);\n\n  /**\n   * @ngdoc method\n   * @module knalli.angular-vertxbus\n   * @methodOf knalli.angular-vertxbus.vertxEventBusServiceProvider\n   * @name .#enable\n   *\n   * @description\n   * Enables or disables the service. This setup is immutable.\n   *\n   * @param {boolean} [value=true] service is enabled on startup\n   * @returns {object} this\n   */\n  this.enable = (value = DEFAULTS.enabled) => {\n    options.enabled = (value === true);\n    return this;\n  };\n\n  /**\n   * @ngdoc method\n   * @module knalli.angular-vertxbus\n   * @methodOf knalli.angular-vertxbus.vertxEventBusServiceProvider\n   * @name .#useDebug\n   *\n   * @description\n   * Enables a verbose mode in which certain events will be logged to `$log`.\n   *\n   * @param {boolean} [value=false] verbose mode (using `$log`)\n   * @returns {object} this\n   */\n  this.useDebug = (value = DEFAULTS.debugEnabled) => {\n    options.debugEnabled = (value === true);\n    return this;\n  };\n\n  /**\n   * @ngdoc method\n   * @module knalli.angular-vertxbus\n   * @methodOf knalli.angular-vertxbus.vertxEventBusServiceProvider\n   * @name .#usePrefix\n   *\n   * @description\n   * Overrides the default prefix which will be used for emitted events.\n   *\n   * @param {string} [value='vertx-eventbus.'] prefix used in event names\n   * @returns {object} this\n   */\n  this.usePrefix = (value = DEFAULTS.prefix) => {\n    options.prefix = value;\n    return this;\n  };\n\n  /**\n   * @ngdoc method\n   * @methodOf knalli.angular-vertxbus.vertxEventBusServiceProvider\n   * @name .#useSockJsStateInterval\n   *\n   *\n   * @description\n   * Overrides the interval of checking the connection is still valid (required for reconnecting automatically).\n   *\n   * @param {boolean} [value=10000] interval of checking the underlying connection's state (in ms)\n   * @returns {object} this\n   */\n  this.useSockJsStateInterval = (value = DEFAULTS.sockjsStateInterval) => {\n    options.sockjsStateInterval = value;\n    return this;\n  };\n\n  /**\n   * @ngdoc method\n   * @methodOf knalli.angular-vertxbus.vertxEventBusServiceProvider\n   * @name .#useMessageBuffer\n   *\n   * @description\n   * Enables buffering of (sending) messages.\n   *\n   * The setting defines the total amount of buffered messages (`0` no buffering). A message will be buffered if\n   * connection is still in progress, the connection is stale or a login is required/pending.\n   *\n   * @param {boolean} [value=0] allowed total amount of messages in the buffer\n   * @returns {object} this\n   */\n  this.useMessageBuffer = (value = DEFAULTS.messageBuffer) => {\n    options.messageBuffer = value;\n    return this;\n  };\n\n  /**\n   * @ngdoc method\n   * @module knalli.angular-vertxbus\n   * @methodOf knalli.angular-vertxbus.vertxEventBusServiceProvider\n   * @name .#authHandler\n   *\n   * @description\n   * Function or service reference name for function checking the authorization state.\n   *\n   * The result of the function must be a boolean or promise. The handler can (but is not required) to create authorization on demand.\n   * If it is resolved, the authorization is valid.\n   * If it is rejected, the authorization is invalid.\n   *\n   * @param {string|function} value authorization handler (either a function or a service name)\n   * @returns {object} promise\n   */\n  this.authHandler = (value) => {\n    options.authHandler = value;\n    options.authRequired = !!value;\n    return this;\n  };\n\n  /**\n   * @ngdoc service\n   * @module knalli.angular-vertxbus\n   * @name knalli.angular-vertxbus.vertxEventBusService\n   * @description\n   * A service utilizing an underlying Vert.x Event Bus\n   *\n   * The advanced features of this service are:\n   *  - broadcasting the connection changes (vertx-eventbus.system.connected, vertx-eventbus.system.disconnected) on $rootScope\n   *  - registering all handlers again when a reconnect had been required\n   *  - supporting a promise when using send()\n   *  - adding aliases on (registerHandler), un (unregisterHandler) and emit (publish)\n   *\n   * Basic usage:\n   * <pre>\n   * module.controller('MyController', function('vertxEventService') {\n *   vertxEventService.on('my.address', function(message) {\n *     console.log(\"JSON Message received: \", message)\n *   });\n *   vertxEventService.publish('my.other.address', {type: 'foo', data: 'bar'});\n * });\n   * </pre>\n   *\n   * Note the additional {@link knalli.angular-vertxbus.vertxEventBusServiceProvider configuration} of the module itself.\n   *\n   * @requires knalli.angular-vertxbus.vertxEventBus\n   * @requires $rootScope\n   * @requires $q\n   * @requires $interval\n   * @requires $log\n   * @requires $injector\n   */\n  /* @ngInject */\n  this.$get = ($rootScope, $q, $interval, vertxEventBus, $log, $injector) => {\n    // Current options (merged defaults with application-wide settings)\n    let instanceOptions = angular.extend({}, vertxEventBus.getOptions(), options);\n    if (instanceOptions.enabled) {\n      return new Delegator(\n        new EventBusDelegate($rootScope, $interval, $log, $q, $injector, vertxEventBus, instanceOptions),\n        $log\n      );\n    } else {\n      return new Delegator(new NoopDelegate());\n    }\n  };\n\n};\n\nexport default VertxEventBusServiceProvider;\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/lib/VertxEventBusServiceProvider.js\n **/","import {moduleName} from '../../../config';\n\nimport Queue from './../../support/Queue';\nimport SimpleMap from './../../support/SimpleMap';\nimport BaseDelegate from './BaseDelegate';\n\n/**\n * @ngdoc event\n * @module knalli.angular-vertxbus\n * @eventOf knalli.angular-vertxbus.vertxEventBusService\n * @eventType broadcast on $rootScope\n * @name disconnected\n *\n * @description\n * After a connection was being terminated.\n *\n * Event name is `prefix + 'system.disconnected'` (see {@link knalli.angular-vertxbus.vertxEventBusServiceProvider#methods_usePrefix prefix})\n */\n\n/**\n * @ngdoc event\n * @module knalli.angular-vertxbus\n * @eventOf knalli.angular-vertxbus.vertxEventBusService\n * @eventType broadcast on $rootScope\n * @name connected\n *\n * @description\n * After a connection was being established\n *\n * Event name is `prefix + 'system.connected'` (see {@link knalli.angular-vertxbus.vertxEventBusServiceProvider#methods_usePrefix prefix})\n */\n\n/**\n * @ngdoc event\n * @module knalli.angular-vertxbus\n * @eventOf knalli.angular-vertxbus.vertxEventBusService\n * @eventType broadcast on $rootScope\n * @name login-succeeded\n *\n * @description\n * After a login has been validated successfully\n *\n * Event name is `prefix + 'system.login.succeeded'` (see {@link knalli.angular-vertxbus.vertxEventBusServiceProvider#methods_usePrefix prefix})\n *\n * @param {object} data data\n * @param {boolean} data.status must be `'ok'`\n */\n\n/**\n * @ngdoc event\n * @module knalli.angular-vertxbus\n * @eventOf knalli.angular-vertxbus.vertxEventBusService\n * @eventType broadcast on $rootScope\n * @name login-failed\n *\n * @description\n * After a login has been destroyed or was invalidated\n *\n * Event name is `prefix + 'system.login.failed'` (see {@link knalli.angular-vertxbus.vertxEventBusServiceProvider#methods_usePrefix prefix})\n *\n * @param {object} data data\n * @param {boolean} data.status must be not`'ok'`\n */\n\nexport default class EventBusDelegate extends BaseDelegate {\n\n  constructor($rootScope, $interval, $log, $q, $injector, eventBus, {\n    enabled,\n    debugEnabled,\n    prefix,\n    sockjsStateInterval,\n    messageBuffer,\n    authRequired,\n    authHandler\n    }) {\n    super();\n    this.$rootScope = $rootScope;\n    this.$interval = $interval;\n    this.$log = $log;\n    this.$q = $q;\n    this.eventBus = eventBus;\n    this.options = {\n      enabled,\n      debugEnabled,\n      prefix,\n      sockjsStateInterval,\n      messageBuffer,\n      authRequired\n    };\n    if (angular.isFunction(authHandler)) {\n      this.authHandler = authHandler;\n    } else if (angular.isString(authHandler)) {\n      try {\n        this.authHandler = $injector.get(authHandler);\n      } catch (e) {\n        if (this.options.debugEnabled) {\n          this.$log.debug('[Vert.x EB Service] Failed to resolve authHandler: %s', e.message);\n        }\n      }\n    }\n    this.connectionState = this.eventBus.EventBus.CLOSED;\n    this.states = {\n      connected: false,\n      authorized: false\n    };\n    this.observers = [];\n    // internal store of buffered messages\n    this.messageQueue = new Queue(this.options.messageBuffer);\n    // internal map of callbacks\n    this.callbackMap = new SimpleMap();\n    // asap\n    this.initialize();\n  }\n\n  // internal\n  initialize() {\n    this.eventBus.onopen = () => this.onEventbusOpen();\n    this.eventBus.onclose = () => this.onEventbusClose();\n\n    // Update the current connection state periodically.\n    let connectionIntervalCheck = () => this.getConnectionState(true);\n    connectionIntervalCheck.displayName = 'connectionIntervalCheck';\n    this.$interval((() => connectionIntervalCheck()), this.options.sockjsStateInterval);\n  }\n\n  // internal\n  onEventbusOpen() {\n    let connectionStateFlipped = false;\n    this.getConnectionState(true);\n    if (!this.states.connected) {\n      this.states.connected = true;\n      connectionStateFlipped = true;\n    }\n    // Ensure all events will be re-attached\n    this.afterEventbusConnected();\n    // Everything is online and registered again, let's notify everybody\n    if (connectionStateFlipped) {\n      this.$rootScope.$broadcast(`${this.options.prefix}system.connected`);\n    }\n    this.$rootScope.$digest(); // explicitly\n    // consume message queue?\n    if (this.options.messageBuffer && this.messageQueue.size()) {\n      while (this.messageQueue.size()) {\n        let fn = this.messageQueue.first();\n        if (angular.isFunction(fn)) {\n          fn();\n        }\n      }\n      this.$rootScope.$digest();\n    }\n  }\n\n  // internal\n  onEventbusClose() {\n    this.getConnectionState(true);\n    if (this.states.connected) {\n      this.states.connected = false;\n      this.$rootScope.$broadcast(`${this.options.prefix}system.disconnected`);\n    }\n  }\n\n  // internal\n  observe(observer) {\n    this.observers.push(observer);\n  }\n\n  // internal\n  afterEventbusConnected() {\n    for (let observer of this.observers) {\n      if (angular.isFunction(observer.afterEventbusConnected)) {\n        observer.afterEventbusConnected();\n      }\n    }\n  }\n\n  registerHandler(address, headers, callback) {\n    if (angular.isFunction(headers) && !callback) {\n      callback = headers;\n      headers = undefined;\n    }\n    if (!angular.isFunction(callback)) {\n      return;\n    }\n    if (this.options.debugEnabled) {\n      this.$log.debug(`[Vert.x EB Service] Register handler for ${address}`);\n    }\n    var callbackWrapper = (err, {body}, replyTo) => {\n      callback(body, replyTo);\n      this.$rootScope.$digest();\n    };\n    callbackWrapper.displayName = `${moduleName}.service.delegate.live.registerHandler.callbackWrapper`;\n    this.callbackMap.put(callback, callbackWrapper);\n    return this.eventBus.registerHandler(address, headers, callbackWrapper);\n  }\n\n  unregisterHandler(address, headers, callback) {\n    if (angular.isFunction(headers) && !callback) {\n      callback = headers;\n      headers = undefined;\n    }\n    if (!angular.isFunction(callback)) {\n      return;\n    }\n    if (this.options.debugEnabled) {\n      this.$log.debug(`[Vert.x EB Service] Unregister handler for ${address}`);\n    }\n    this.eventBus.unregisterHandler(address, headers, this.callbackMap.get(callback));\n    this.callbackMap.remove(callback);\n  }\n\n  send(address, message, headers, timeout = 10000, expectReply = true) {\n    let deferred = this.$q.defer();\n    let next = () => {\n      if (expectReply) {\n        // Register timeout for promise rejecting\n        let timer = this.$interval((() => {\n          if (this.options.debugEnabled) {\n            this.$log.debug(`[Vert.x EB Service] send('${address}') timed out`);\n          }\n          deferred.reject();\n        }), timeout, 1);\n        // Send message\n        this.eventBus.send(address, message, headers, (err, reply) => {\n          this.$interval.cancel(timer); // because it's resolved\n          if (err) {\n            deferred.reject(err);\n          } else {\n            deferred.resolve(reply);\n          }\n        });\n      } else {\n        this.eventBus.send(address, message, headers);\n        deferred.resolve(); // we don't care\n      }\n    };\n    next.displayName = `${moduleName}.service.delegate.live.send.next`;\n    this.ensureOpenAuthConnection(next).then(null, deferred.reject);\n    return deferred.promise;\n  }\n\n  publish(address, message, headers) {\n    return this.ensureOpenAuthConnection(() => this.eventBus.publish(address, message, headers));\n  }\n\n  /**\n   * Ensures the callback will be performed with an open connection.\n   *\n   * Unless an open connection was found, the callback will be queued in the message buffer (if available).\n   *\n   * @param {function} fn callback\n   * @returns {object} promise (resolved on either performed or queued)\n   */\n  ensureOpenConnection(fn) {\n    const deferred = this.$q.defer();\n    if (this.isConnectionOpen()) {\n      fn();\n      deferred.resolve({\n        inQueue: false\n      });\n    } else if (this.options.messageBuffer) {\n      this.messageQueue.push(fn);\n      deferred.resolve({\n        inQueue: true\n      });\n    } else {\n      deferred.reject();\n    }\n    return deferred.promise;\n  }\n\n  /**\n   * Ensures the callback will be performed with a valid session.\n   *\n   * Unless `authRequired` is enabled, this will be simple forward.\n   *\n   * Unless a valid session exist (but required), the callback will be not invoked.\n   *\n   * @param {function} fn callback\n   * @returns {object} promise (resolved on either performed or queued)\n   */\n  ensureOpenAuthConnection(fn) {\n    if (!this.options.authRequired) {\n      // easy: no login required\n      return this.ensureOpenConnection(fn);\n    } else {\n      let fnWrapper = () => {\n        if (this.authHandler) {\n          const onValidAuth = () => {\n            this.states.authorized = true;\n            fn();\n          };\n          const onInvalidAuth = () => {\n            this.states.authorized = false;\n            if (this.options.debugEnabled) {\n              this.$log.debug('[Vert.x EB Service] Message was not sent due authHandler rejected');\n            }\n          };\n          const authResult = this.authHandler(this.eventBus);\n          if (!(authResult && angular.isFunction(authResult.then))) {\n            if (this.options.debugEnabled) {\n              this.$log.debug('[Vert.x EB Service] Message was not sent because authHandler is returning not a promise');\n            }\n            return false;\n          }\n          authResult.then(onValidAuth, onInvalidAuth);\n          return true;\n        } else {\n          // ignore this message\n          if (this.options.debugEnabled) {\n            this.$log.debug('[Vert.x EB Service] Message was not sent because no authHandler is defined');\n          }\n          return false;\n        }\n      };\n      fnWrapper.displayName = `${moduleName}.service.delegate.live.ensureOpenAuthConnection.fnWrapper`;\n      return this.ensureOpenConnection(fnWrapper);\n    }\n  }\n\n  /**\n   * Returns the current connection state. The state is being cached internally.\n   *\n   * @param {boolean=} [immediate=false] if true, the connection state will be queried directly.\n   * @returns {number} state type of vertx.EventBus\n   */\n  getConnectionState(immediate) {\n    if (this.options.enabled) {\n      if (immediate) {\n        this.connectionState = this.eventBus.state;\n      }\n    } else {\n      this.connectionState = this.eventBus.EventBus.CLOSED;\n    }\n    return this.connectionState;\n  }\n\n  /**\n   * Returns true if the current connection state ({@link knalli.angular-vertxbus.vertxEventBusService#methods_getConnectionState getConnectionState()}) is `OPEN`.\n   *\n   * @returns {boolean} connection open state\n   */\n  isConnectionOpen() {\n    return this.getConnectionState() === this.eventBus.EventBus.OPEN;\n  }\n\n  /**\n   * Returns true if the session is valid\n   *\n   * @returns {boolean} state\n   */\n  isAuthorized() {\n    return this.states.authorized;\n  }\n\n  // internal\n  isConnected() {\n    return this.states.connected;\n  }\n\n  isEnabled() {\n    return this.options.enabled;\n  }\n\n  /**\n   * Returns the current amount of messages in the internal buffer.\n   *\n   * @returns {number} amount\n   */\n  getMessageQueueLength() {\n    return this.messageQueue.size();\n  }\n\n}\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/lib/service/delegate/EventBusDelegate.js\n **/","/*\n Simple queue implementation\n\n FIFO: #push() + #first()\n LIFO: #push() + #last()\n */\nexport default class Queue {\n\n  constructor(maxSize = 10) {\n    this.maxSize = maxSize;\n    this.items = [];\n  }\n\n  push(item) {\n    this.items.push(item);\n    return this.recalibrateBufferSize();\n  }\n\n  recalibrateBufferSize() {\n    while (this.items.length > this.maxSize) {\n      this.first();\n    }\n    return this;\n  }\n\n  last() {\n    return this.items.pop();\n  }\n\n  first() {\n    return this.items.shift(0);\n  }\n\n  size() {\n    return this.items.length;\n  }\n\n}\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/lib/support/Queue.js\n **/","/*\n Simple Map implementation\n\n This implementation allows usage of non serializable keys for values.\n */\nexport default class SimpleMap {\n\n  constructor() {\n    this.clear();\n  }\n\n  // Stores the value under the key.\n  // Chainable\n  put(key, value) {\n    var idx = this._indexForKey(key);\n    if (idx > -1) {\n      this.values[idx] = value;\n    } else {\n      this.keys.push(key);\n      this.values.push(value);\n    }\n    return this;\n  }\n\n  // Returns value for key, otherwise undefined.\n  get(key) {\n    var idx = this._indexForKey(key);\n    if (idx > -1) {\n      return this.values[idx];\n    }\n  }\n\n  // Returns true if the key exists.\n  containsKey(key) {\n    let idx = this._indexForKey(key);\n    return idx > -1;\n  }\n\n  // Returns true if the value exists.\n  containsValue(value) {\n    let idx = this._indexForValue(value);\n    return idx > -1;\n  }\n\n  // Removes the key and its value.\n  remove(key) {\n    let idx = this._indexForKey(key);\n    if (idx > -1) {\n      this.keys[idx] = undefined;\n      this.values[idx] = undefined;\n    }\n\n  }\n\n  // Clears all keys and values.\n  clear() {\n    this.keys = [];\n    this.values = [];\n    return this;\n  }\n\n  // Returns index of key, otherwise -1.\n  _indexForKey(key) {\n    for (let i in this.keys) {\n      if (key === this.keys[i]) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  _indexForValue(value) {\n    for (let i in this.values) {\n      if (value === this.values[i]) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n}\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/lib/support/SimpleMap.js\n **/","export default class BaseDelegate {\n\n  observe() {}\n\n  getConnectionState() {\n    return 3; // CLOSED\n  }\n\n  isConnectionOpen() {\n    return false;\n  }\n\n  isAuthorized() {\n    return false;\n  }\n\n  isEnabled() {\n    return false;\n  }\n\n  isConnected() {\n    return false;\n  }\n\n  send() {}\n\n  publish() {}\n\n}\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/lib/service/delegate/BaseDelegate.js\n **/","import BaseDelegate from './BaseDelegate';\n\nexport default class NoopDelegate extends BaseDelegate {}\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/lib/service/delegate/NoopDelegate.js\n **/","import {moduleName} from '../../config';\n\nexport default class Delegator {\n\n  constructor(delegate, $log) {\n    this.delegate = delegate;\n    this.$log = $log;\n    this.handlers = {};\n    this.delegate.observe({\n      afterEventbusConnected: () => this.afterEventbusConnected()\n    });\n  }\n\n  afterEventbusConnected() {\n    for (let address in this.handlers) {\n      if (Object.prototype.hasOwnProperty.call(this.handlers, address)) {\n        let callbacks = this.handlers[address];\n        if (callbacks && callbacks.length) {\n          for (let {headers, callback} of callbacks) {\n            this.delegate.registerHandler(address, headers, callback);\n          }\n        }\n      }\n    }\n  }\n\n  /**\n   * @ngdoc method\n   * @module knalli.angular-vertxbus\n   * @methodOf knalli.angular-vertxbus.vertxEventBusService\n   * @name .#registerHandler\n   *\n   * @description\n   * Registers a callback handler for the specified address match.\n   *\n   * @param {string} address target address\n   * @param {object} headers optional headers\n   * @param {function} callback handler with params `(message, replyTo)`\n   * @returns {function} deconstructor\n   */\n  registerHandler(address, headers, callback) {\n    if (!this.handlers[address]) {\n      this.handlers[address] = [];\n    }\n    var handler = {headers, callback};\n    this.handlers[address].push(handler);\n    var unregisterFn = null;\n    if (this.delegate.isConnectionOpen()) {\n      this.delegate.registerHandler(address, headers, callback);\n      unregisterFn = () => this.delegate.unregisterHandler(address, headers, callback);\n    }\n    // and return the deregister callback\n    var deconstructor = () => {\n      if (unregisterFn) {\n        unregisterFn();\n        unregisterFn = undefined;\n      }\n      // Remove from internal map\n      if (this.handlers[address]) {\n        var index = this.handlers[address].indexOf(handler);\n        if (index > -1) {\n          this.handlers[address].splice(index, 1);\n        }\n        if (this.handlers[address].length < 1) {\n          this.handlers[address] = undefined;\n        }\n      }\n    };\n    deconstructor.displayName = `${moduleName}.service.registerHandler.deconstructor`;\n    return deconstructor;\n  }\n\n  /**\n   * @ngdoc method\n   * @module knalli.angular-vertxbus\n   * @methodOf knalli.angular-vertxbus.vertxEventBusService\n   * @name .#on\n   *\n   * @description\n   * See (using {@link knalli.angular-vertxbus.vertxEventBusService#methods_registerHandler registerHandler()})\n   */\n  on(address, headers, callback) {\n    return this.registerHandler(address, headers, callback);\n  }\n\n  /**\n   * @ngdoc method\n   * @module knalli.angular-vertxbus\n   * @methodOf knalli.angular-vertxbus.vertxEventBusService\n   * @name .#addListener\n   *\n   * @description\n   * See (using {@link knalli.angular-vertxbus.vertxEventBusService#methods_registerHandler registerHandler()})\n   */\n  addListener(address, headers, callback) {\n    return this.registerHandler(address, headers, callback);\n  }\n\n  /**\n   * @ngdoc method\n   * @module knalli.angular-vertxbus\n   * @methodOf knalli.angular-vertxbus.vertxEventBusService\n   * @name .#unregisterHandler\n   *\n   * @description\n   * Removes a callback handler for the specified address match.\n   *\n   * @param {string} address target address\n   * @param {object} headers optional headers\n   * @param {function} callback handler with params `(message, replyTo)`\n   */\n  unregisterHandler(address, headers, callback) {\n    // Remove from internal map\n    if (this.handlers[address]) {\n      var index = this.handlers[address].indexOf({headers, callback});\n      if (index > -1) {\n        this.handlers[address].splice(index, 1);\n      }\n      if (this.handlers[address].length < 1) {\n        this.handlers[address] = undefined;\n      }\n    }\n    // Remove from real instance\n    if (this.delegate.isConnectionOpen()) {\n      this.delegate.unregisterHandler(address, headers, callback);\n    }\n  }\n\n  /**\n   * @ngdoc method\n   * @module knalli.angular-vertxbus\n   * @methodOf knalli.angular-vertxbus.vertxEventBusService\n   * @name .#un\n   *\n   * @description\n   * See (using {@link knalli.angular-vertxbus.vertxEventBusService#methods_registerHandler unregisterHandler()})\n   */\n  un(address, headers, callback) {\n    return this.unregisterHandler(address, headers, callback);\n  }\n\n  /**\n   * @ngdoc method\n   * @module knalli.angular-vertxbus\n   * @methodOf knalli.angular-vertxbus.vertxEventBusService\n   * @name .#removeListener\n   *\n   * @description\n   * See (using {@link knalli.angular-vertxbus.vertxEventBusService#methods_registerHandler unregisterHandler()})\n   */\n  removeListener(address, headers, callback) {\n    return this.unregisterHandler(address, headers, callback);\n  }\n\n  /**\n   * @ngdoc method\n   * @module knalli.angular-vertxbus\n   * @methodOf knalli.angular-vertxbus.vertxEventBusService\n   * @name .#send\n   *\n   * @description\n   * Sends a message to the specified address (using {@link knalli.angular-vertxbus.vertxEventBus#methods_send vertxEventBus.send()}).\n   *\n   * @param {string} address target address\n   * @param {object} message payload message\n   * @param {object} headers headers\n   * @param {number=} [options.timeout=10000] (in ms) after which the promise will be rejected\n   * @param {boolean=} [options.expectReply=true] if false, the promise will be resolved directly and\n   *                                       no replyHandler will be created\n   * @returns {object} promise\n   */\n  send(address, message, headers = {}, options = {timeout: 10000, expectReply: true}) {\n    return this.delegate.send(address, message, headers, options.timeout, options.expectReply);\n  }\n\n  /**\n   * @ngdoc method\n   * @module knalli.angular-vertxbus\n   * @methodOf knalli.angular-vertxbus.vertxEventBusService\n   * @name .#publish\n   *\n   * @description\n   * Publishes a message to the specified address (using {@link knalli.angular-vertxbus.vertxEventBus#methods_publish vertxEventBus.publish()}).\n   *\n   * @param {string} address target address\n   * @param {object} message payload message\n   * @param {object=} headers headers\n   * @returns {object} promise (resolved on either performed or queued)\n   */\n  publish(address, message, headers = {}) {\n    return this.delegate.publish(address, message, headers);\n  }\n\n  /**\n   * @ngdoc method\n   * @module knalli.angular-vertxbus\n   * @methodOf knalli.angular-vertxbus.vertxEventBusService\n   * @name .#emit\n   *\n   * @description\n   * See (using {@link knalli.angular-vertxbus.vertxEventBusService#methods_publish publish()})\n   */\n  emit(address, message, headers = {}) {\n    return this.publish(address, message, headers);\n  }\n\n  /**\n   * @ngdoc method\n   * @module knalli.angular-vertxbus\n   * @methodOf knalli.angular-vertxbus.vertxEventBusService\n   * @name .#getConnectionState\n   *\n   * @description\n   * Returns the current connection state. The state is being cached internally.\n   *\n   * @returns {number} state type of vertx.EventBus\n   */\n  getConnectionState() {\n    return this.delegate.getConnectionState();\n  }\n\n  /**\n   * @ngdoc method\n   * @module knalli.angular-vertxbus\n   * @methodOf knalli.angular-vertxbus.vertxEventBusService\n   * @name .#readyState\n   *\n   * @description\n   * See (using {@link knalli.angular-vertxbus.vertxEventBusService#methods_getConnectionState getConnectionState()})\n   */\n  readyState() {\n    return this.getConnectionState();\n  }\n\n\n\n  /**\n   * @ngdoc method\n   * @module knalli.angular-vertxbus\n   * @methodOf knalli.angular-vertxbus.vertxEventBusService\n   * @name .#isConnectionOpen\n   *\n   * @description\n   * Returns true if the current connection state ({@link knalli.angular-vertxbus.vertxEventBusService#methods_getConnectionState getConnectionState()}) is `OPEN`.\n   *\n   * @returns {boolean} connection open state\n   */\n  isConnectionOpen() {\n    return this.isConnectionOpen();\n  }\n\n  /**\n   * @ngdoc method\n   * @module knalli.angular-vertxbus\n   * @methodOf knalli.angular-vertxbus.vertxEventBusService\n   * @name .#isEnabled\n   *\n   * @description\n   * Returns true if service is being enabled.\n   *\n   * @returns {boolean} state\n   */\n  isEnabled() {\n    return this.delegate.isEnabled();\n  }\n\n  /**\n   * @ngdoc method\n   * @module knalli.angular-vertxbus\n   * @methodOf knalli.angular-vertxbus.vertxEventBusService\n   * @name .#isConnected\n   *\n   * @description\n   * Returns true if service (and the eventbus) is being connected.\n   *\n   * @returns {boolean} state\n   */\n  isConnected() {\n    return this.delegate.isConnected();\n  }\n\n  /**\n   * @ngdoc method\n   * @module knalli.angular-vertxbus\n   * @methodOf knalli.angular-vertxbus.vertxEventBusService\n   * @name .#isAuthorized\n   *\n   * @description\n   * Returns true if the authorization is valid\n   *\n   * @returns {boolean} state\n   */\n  isAuthorized() {\n    return this.delegate.isAuthorized();\n  }\n\n  /**\n   * @ngdoc method\n   * @module knalli.angular-vertxbus\n   * @methodOf knalli.angular-vertxbus.vertxEventBusService\n   * @name .#isValidSession\n   *\n   * See (using {@link knalli.angular-vertxbus.vertxEventBusService#methods_isAuthorized isAuthorized()})\n   */\n  isValidSession() {\n    return this.delegate.isAuthorized();\n  }\n\n  /**\n   * @ngdoc method\n   * @module knalli.angular-vertxbus\n   * @methodOf knalli.angular-vertxbus.vertxEventBusService\n   * @name .#getMessageQueueLength\n   *\n   * @description\n   * Returns the current amount of messages in the internal buffer.\n   *\n   * @returns {number} amount\n   */\n  getMessageQueueLength() {\n    return this.delegate.getMessageQueueLength();\n  }\n\n}\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/lib/service/Delegator.js\n **/"],"sourceRoot":""}