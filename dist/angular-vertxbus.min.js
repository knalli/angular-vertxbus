/*! angular-vertxbus - v3.2.0 - 2015-10-31
* http://github.com/knalli/angular-vertxbus
* Copyright (c) 2015 Jan Philipp; Licensed MIT */
!function a(b,c,d){function e(g,h){if(!c[g]){if(!b[g]){var i="function"==typeof require&&require;if(!h&&i)return i(g,!0);if(f)return f(g,!0);var j=new Error("Cannot find module '"+g+"'");throw j.code="MODULE_NOT_FOUND",j}var k=c[g]={exports:{}};b[g][0].call(k.exports,function(a){var c=b[g][1][a];return e(c?c:a)},k,k.exports,a,b,c,d)}return c[g].exports}for(var f="function"==typeof require&&require,g=0;g<d.length;g++)e(d[g]);return e}({1:[function(a,b,c){"use strict";Object.defineProperty(c,"__esModule",{value:!0});var d="knalli.angular-vertxbus";c.moduleName=d},{}],2:[function(a,b,c){"use strict";function d(a){return a&&a.__esModule?a:{"default":a}}Object.defineProperty(c,"__esModule",{value:!0});var e=a("./module"),f=d(e);c["default"]=f["default"]},{"./module":15}],3:[function(a,b,c){"use strict";function d(a){return a&&a.__esModule?a:{"default":a}}Object.defineProperty(c,"__esModule",{value:!0});var e=a("./service/delegate/EventBusDelegate"),f=d(e),g=a("./service/delegate/NoopDelegate"),h=d(g),i=a("./service/Delegator"),j=d(i),k={enabled:!0,debugEnabled:!1,loginRequired:!1,prefix:"vertx-eventbus.",sockjsStateInterval:1e4,messageBuffer:1e4},l=function(){var a=this,b=angular.extend({},k);/**
   * @ngdoc method
   * @module knalli.angular-vertxbus
   * @methodOf knalli.angular-vertxbus.vertxEventBusServiceProvider
   * @name .#enable
   *
   * @description
   * Enables or disables the service. This setup is immutable.
   *
   * @param {boolean} [value=true] service is enabled on startup
   * @returns {object} this
   */
this.enable=function(){var c=arguments.length<=0||void 0===arguments[0]?k.enabled:arguments[0];return b.enabled=c===!0,a},/**
   * @ngdoc method
   * @module knalli.angular-vertxbus
   * @methodOf knalli.angular-vertxbus.vertxEventBusServiceProvider
   * @name .#useDebug
   *
   * @description
   * Enables a verbose mode in which certain events will be logged to `$log`.
   *
   * @param {boolean} [value=false] verbose mode (using `$log`)
   * @returns {object} this
   */
this.useDebug=function(){var c=arguments.length<=0||void 0===arguments[0]?k.debugEnabled:arguments[0];return b.debugEnabled=c===!0,a},/**
   * @ngdoc method
   * @module knalli.angular-vertxbus
   * @methodOf knalli.angular-vertxbus.vertxEventBusServiceProvider
   * @name .#usePrefix
   *
   * @description
   * Overrides the default prefix which will be used for emitted events.
   *
   * @param {string} [value='vertx-eventbus.'] prefix used in event names
   * @returns {object} this
   */
this.usePrefix=function(){var c=arguments.length<=0||void 0===arguments[0]?k.prefix:arguments[0];return b.prefix=c,a},/**
   * @ngdoc method
   * @methodOf knalli.angular-vertxbus.vertxEventBusServiceProvider
   * @name .#requireLogin
   *
   *
   * @description
   * Defines whether a login is being required or not.
   *
   * @param {boolean} [value=false] defines requirement of a valid session
   * @returns {object} this
   */
this.requireLogin=function(){var c=arguments.length<=0||void 0===arguments[0]?k.loginRequired:arguments[0];return b.loginRequired=c===!0,a},/**
   * @ngdoc method
   * @methodOf knalli.angular-vertxbus.vertxEventBusServiceProvider
   * @name .#useSockJsStateInterval
   *
   *
   * @description
   * Overrides the interval of checking the connection is still valid (required for reconnecting automatically).
   *
   * @param {boolean} [value=10000] interval of checking the underlying connection's state (in ms)
   * @returns {object} this
   */
this.useSockJsStateInterval=function(){var c=arguments.length<=0||void 0===arguments[0]?k.sockjsStateInterval:arguments[0];return b.sockjsStateInterval=c,a},/**
   * @ngdoc method
   * @methodOf knalli.angular-vertxbus.vertxEventBusServiceProvider
   * @name .#useMessageBuffer
   *
   * @description
   * Enables buffering of (sending) messages.
   *
   * The setting defines the total amount of buffered messages (`0` no buffering). A message will be buffered if
   * connection is still in progress, the connection is stale or a login is required/pending.
   *
   * @param {boolean} [value=0] allowed total amount of messages in the buffer
   * @returns {object} this
   */
this.useMessageBuffer=function(){var c=arguments.length<=0||void 0===arguments[0]?k.messageBuffer:arguments[0];return b.messageBuffer=c,a},/**
   * @ngdoc method
   * @methodOf knalli.angular-vertxbus.vertxEventBusServiceProvider
   * @name .#useLoginInterceptor
   *
   * @description
   * Defines a login interceptor corresponding for the option `loginRequired`.
   *
   * The argument must be a valid function reference with four arguments
   * - send (an at runtime injected function for actual sending: i.e. `send(address, message, next)`
   * - username (the used username)
   * - password (the used password)
   * - next (the callback function reference)
   *
   * @param {function} a function with params `(send, username, password, next)`
   * @returns {object} this
   */
this.useLoginInterceptor=function(c){return b.loginInterceptor=c,a},/**
   * @ngdoc method
   * @methodOf knalli.angular-vertxbus.vertxEventBusServiceProvider
   * @name .#configureLoginInterceptor
   *
   * @description
   * Configures and defines a login interceptor corresponding for the option #requireLogin().
   *
   * This utilizes #useLoginInterceptor and is available as a convenient method.
   *
   * At default, the created request will look similar like vertx.basicauthmanager.login.
   *
   * @param {string} the address to send
   * @param {function=} optional a builder for creating the message body
   * @returns {object} this
   */
this.configureLoginInterceptor=function(b,c){
// Legacy fallback: create a message like in Vert.x 2
return c||(c=function(a,b){return{action:"findone",collection:"users",matcher:{username:a,password:b}}}),a.useLoginInterceptor(function(a,d,e,f){a(b,c(d,e),f)})},/**
   * @ngdoc service
   * @module knalli.angular-vertxbus
   * @name knalli.angular-vertxbus.vertxEventBusService
   * @description
   * A service utilizing an underlying Vert.x Event Bus
   *
   * The advanced features of this service are:
   *  - broadcasting the connection changes (vertx-eventbus.system.connected, vertx-eventbus.system.disconnected) on $rootScope
   *  - registering all handlers again when a reconnect had been required
   *  - supporting a promise when using send()
   *  - adding aliases on (registerHandler), un (unregisterHandler) and emit (publish)
   *
   * Basic usage:
   * <pre>
   * module.controller('MyController', function('vertxEventService') {
  *   vertxEventService.on('my.address', function(message) {
  *     console.log("JSON Message received: ", message)
  *   });
  *   vertxEventService.publish('my.other.address', {type: 'foo', data: 'bar'});
  * });
   * </pre>
   *
   * Note the additional {@link knalli.angular-vertxbus.vertxEventBusServiceProvider configuration} of the module itself.
   *
   * @requires knalli.angular-vertxbus.vertxEventBus
   * @requires $rootScope
   * @requires $q
   * @requires $interval
   * @requires $log
   */
/* @ngInject */
this.$get=function(a,c,d,e,g){
// Current options (merged defaults with application-wide settings)
var i=angular.extend({},e.getOptions(),b);return i.enabled?new j["default"](new f["default"](a,d,g,c,e,i),g):new j["default"](new h["default"])},this.$get.$inject=["$rootScope","$q","$interval","vertxEventBus","$log"]};c["default"]=l},{"./service/Delegator":8,"./service/delegate/EventBusDelegate":10,"./service/delegate/NoopDelegate":11}],4:[function(a,b,c){"use strict";function d(a){return a&&a.__esModule?a:{"default":a}}Object.defineProperty(c,"__esModule",{value:!0});var e=a("./adapter/EventBusAdapter"),f=d(e),g=a("./adapter/NoopAdapter"),h=d(g),i=a("./support/ConnectionConfigHolder"),j=d(i),k={enabled:!0,debugEnabled:!1,initialConnectEnabled:!0,urlServer:location.protocol+"//"+location.hostname+(function(){return location.port?":"+location.port:void 0}()||""),urlPath:"/eventbus",reconnectEnabled:!0,sockjsReconnectInterval:1e4,sockjsOptions:{}},l=function(){var a=this,b=angular.extend({},k);/**
   * @ngdoc method
   * @module knalli.angular-vertxbus
   * @methodOf knalli.angular-vertxbus.vertxEventBusProvider
   * @name .#enable
   *
   * @description
   * Enables or disables the service. This setup is immutable.
   *
   * @param {boolean} [value=true] service is enabled on startup
   * @returns {object} this
   */
this.enable=function(){var c=arguments.length<=0||void 0===arguments[0]?k.enabled:arguments[0];return b.enabled=c===!0,a},/**
   * @ngdoc method
   * @module knalli.angular-vertxbus
   * @methodOf knalli.angular-vertxbus.vertxEventBusProvider
   * @name .#disableAutoConnect
   *
   * @description
   * Disables the auto connection feature.
   *
   * This feature will be only available if `enable == true`.
   *
   * @param {boolean} [value=true] auto connect on startup
   * @returns {object} this
   */
this.disableAutoConnect=function(){return b.initialConnectEnabled=!1,a},/**
   * @ngdoc method
   * @module knalli.angular-vertxbus
   * @methodOf knalli.angular-vertxbus.vertxEventBusProvider
   * @name .#useDebug
   *
   * @description
   * Enables a verbose mode in which certain events will be logged to `$log`.
   *
   * @param {boolean} [value=false] verbose mode (using `$log`)
   * @returns {object} this
   */
this.useDebug=function(){var c=arguments.length<=0||void 0===arguments[0]?k.debugEnabled:arguments[0];return b.debugEnabled=c===!0,a},/**
   * @ngdoc method
   * @module knalli.angular-vertxbus
   * @methodOf knalli.angular-vertxbus.vertxEventBusProvider
   * @name .#useUrlServer
   *
   * @description
   * Overrides the url part "server" for connecting. The default is based on
   * - `location.protocol`
   * - `location.hostname`
   * - `location.port`
   *
   * i.e. `http://domain.tld` or `http://domain.tld:port`
   *
   * @param {boolean} [value=$computed] server to connect (default based on `location.protocol`, `location.hostname` and `location.port`)
   * @returns {object} this
   */
this.useUrlServer=function(){var c=arguments.length<=0||void 0===arguments[0]?k.urlServer:arguments[0];return b.urlServer=c,a},/**
   * @ngdoc method
   * @module knalli.angular-vertxbus
   * @methodOf knalli.angular-vertxbus.vertxEventBusProvider
   * @name .#useUrlPath
   *
   * @description
   * Overrides the url part "path" for connection.
   *
   * @param {boolean} [value='/eventbus'] path to connect
   * @returns {object} this
   */
this.useUrlPath=function(){var c=arguments.length<=0||void 0===arguments[0]?k.urlPath:arguments[0];return b.urlPath=c,a},/**
   * @ngdoc method
   * @module knalli.angular-vertxbus
   * @methodOf knalli.angular-vertxbus.vertxEventBusProvider
   * @name .#useReconnect
   *
   * @description
   * Enables or disables the automatic reconnect handling.
   *
   * @param {boolean} [value=true] if a disconnect was being noted, a reconnect will be enforced automatically
   * @returns {object} this
   */
this.useReconnect=function(){var c=arguments.length<=0||void 0===arguments[0]?k.reconnectEnabled:arguments[0];return b.reconnectEnabled=c,a},/**
   * @ngdoc method
   * @module knalli.angular-vertxbus
   * @methodOf knalli.angular-vertxbus.vertxEventBusProvider
   * @name .#useSockJsReconnectInterval
   *
   * @description
   * Overrides the timeout for reconnecting after a disconnect was found.
   *
   * @param {boolean} [value=10000] time between a disconnect and the next try to reconnect (in ms)
   * @returns {object} this
   */
this.useSockJsReconnectInterval=function(){var c=arguments.length<=0||void 0===arguments[0]?k.sockjsReconnectInterval:arguments[0];return b.sockjsReconnectInterval=c,a},/**
   * @ngdoc method
   * @module knalli.angular-vertxbus
   * @methodOf knalli.angular-vertxbus.vertxEventBusProvider
   * @name .#useSockJsOptions
   *
   * @description
   * Sets additional params for the `SockJS` instance.
   *
   * Internally, it will be applied (as `options`) like `new SockJS(url, undefined, options)`.
   *
   * @param {boolean} [value={}]  optional params for raw SockJS options
   * @returns {object} this
   */
this.useSockJsOptions=function(){var c=arguments.length<=0||void 0===arguments[0]?k.sockjsOptions:arguments[0];return b.sockjsOptions=c,a},/**
   * @ngdoc service
   * @module knalli.angular-vertxbus
   * @name knalli.angular-vertxbus.vertxEventBus
   * @description
   * A stub representing the Vert.x EventBus (core functionality)
   *
   * Because the Event Bus cannot handle a reconnect (because of the underlaying SockJS), a
   * new instance of the bus have to be created.
   * This stub ensures only one object holding the current active instance of the bus.
   *
   * The stub supports theses Vert.x Event Bus APIs:
   *  - {@link knalli.angular-vertxbus.vertxEventBus#methods_close close()}
   *  - {@link knalli.angular-vertxbus.vertxEventBus#methods_login login(username, password, replyHandler)}
   *  - {@link knalli.angular-vertxbus.vertxEventBus#methods_send send(address, message, handler)}
   *  - {@link knalli.angular-vertxbus.vertxEventBus#methods_publish publish(address, message)}
   *  - {@link knalli.angular-vertxbus.vertxEventBus#methods_registerHandler registerHandler(adress, handler)}
   *  - {@link knalli.angular-vertxbus.vertxEventBus#methods_unregisterHandler unregisterHandler(address, handler)}
   *  - {@link knalli.angular-vertxbus.vertxEventBus#methods_readyState readyState()}
   *
   * Furthermore, the stub supports theses extra APIs:
   *  - {@link knalli.angular-vertxbus.vertxEventBus#methods_reconnect reconnect()}
   *
   * @requires $timeout
   * @requires $log
   */
/* @ngInject */
this.$get=function(a,c,d){
// Current options (merged defaults with application-wide settings)
var e=angular.extend({},k,b);
// aggregate server connection params
return e.enabled&&vertx&&vertx.EventBus?(e.debugEnabled&&c.debug("[Vert.x EB Stub] Enabled"),e.connectionConfig=new j["default"]({urlServer:e.urlServer,urlPath:e.urlPath}),delete e.urlServer,delete e.urlPath,new f["default"](vertx.EventBus,a,c,d,e)):(e.debugEnabled&&c.debug("[Vert.x EB Stub] Disabled"),new h["default"](vertx.EventBus,d))},this.$get.$inject=["$timeout","$log","$q"]};c["default"]=l},{"./adapter/EventBusAdapter":6,"./adapter/NoopAdapter":7,"./support/ConnectionConfigHolder":12}],5:[function(a,b,c){"use strict";function d(a,b){if(!(a instanceof b))throw new TypeError("Cannot call a class as a function")}var e=function(){function a(a,b){for(var c=0;c<b.length;c++){var d=b[c];d.enumerable=d.enumerable||!1,d.configurable=!0,"value"in d&&(d.writable=!0),Object.defineProperty(a,d.key,d)}}return function(b,c,d){return c&&a(b.prototype,c),d&&a(b,d),b}}();Object.defineProperty(c,"__esModule",{value:!0});var f=function(){function a(b){d(this,a),this.$q=b}return e(a,[{key:"configureConnection",value:function(){}},{key:"connect",value:function(){return this.$q.reject()}},{key:"reconnect",value:function(){}},{key:"close",value:function(){}},{key:"login",value:function(){}},{key:"send",value:function(){}},{key:"publish",value:function(){}},{key:"registerHandler",value:function(){}},{key:"unregisterHandler",value:function(){}},{key:"readyState",value:function(){}},{key:"getOptions",value:function(){return{}}},{key:"onopen",value:function(){}},{key:"onclose",value:function(){}}]),a}();c["default"]=f},{}],6:[function(a,b,c){"use strict";function d(a){return a&&a.__esModule?a:{"default":a}}function e(a,b){if(!(a instanceof b))throw new TypeError("Cannot call a class as a function")}function f(a,b){if(!a)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return!b||"object"!=typeof b&&"function"!=typeof b?a:b}function g(a,b){if("function"!=typeof b&&null!==b)throw new TypeError("Super expression must either be null or a function, not "+typeof b);a.prototype=Object.create(b&&b.prototype,{constructor:{value:a,enumerable:!1,writable:!0,configurable:!0}}),b&&(Object.setPrototypeOf?Object.setPrototypeOf(a,b):a.__proto__=b)}var h=function(){function a(a,b){for(var c=0;c<b.length;c++){var d=b[c];d.enumerable=d.enumerable||!1,d.configurable=!0,"value"in d&&(d.writable=!0),Object.defineProperty(a,d.key,d)}}return function(b,c,d){return c&&a(b.prototype,c),d&&a(b,d),b}}();Object.defineProperty(c,"__esModule",{value:!0});var i=a("../../config.js"),j=a("./BaseAdapter"),k=d(j),l=a("./../support/ConnectionConfigHolder"),m=d(l),n=function(a){function b(a,c,d,g,h){e(this,b);var i=h.enabled,j=h.debugEnabled,k=h.initialConnectEnabled,l=h.connectionConfig,m=h.reconnectEnabled,n=h.sockjsReconnectInterval,o=h.sockjsOptions,p=f(this,Object.getPrototypeOf(b).call(this,g));
// asap create connection
return p.EventBus=a,p.$timeout=c,p.$log=d,p.$q=g,p.options={enabled:i,debugEnabled:j,initialConnectEnabled:k,connectionConfig:l,reconnectEnabled:m,sockjsReconnectInterval:n,sockjsOptions:o},p.disconnectTimeoutEnabled=!0,k&&p.connect(),p}/**
   * @ngdoc method
   * @module knalli.angular-vertxbus
   * @methodOf knalli.angular-vertxbus.vertxEventBus
   * @name .#configureConnect
   *
   * @description
   * Reconfigure the connection details.
   *
   * @param {string} urlServer see {@link knalli.angular-vertxbus.vertxEventBusProvider#methods_useUrlServer vertxEventBusProvider.useUrlServer()}
   * @param {string} [urlPath=/eventbus] see {@link knalli.angular-vertxbus.vertxEventBusProvider#methods_useUrlPath vertxEventBusProvider.useUrlPath()}
   */
return g(b,a),h(b,[{key:"configureConnection",value:function(a){var b=arguments.length<=1||void 0===arguments[1]?"/eventbus":arguments[1];return this.options.connectionConfig=new m["default"]({urlServer:a,urlPath:b}),this}},{key:"connect",value:function(){var a=this,b=this.$q.defer(),c=""+this.options.connectionConfig.urlServer+this.options.connectionConfig.urlPath;
// Because we have rebuild an EventBus object (because it have to rebuild a SockJS object)
// we must wrap the object. Therefore, we have to mimic the behavior of onopen and onclose each time.
// instance onClose handler
return this.options.debugEnabled&&this.$log.debug("[Vert.x EB Stub] Enabled: connecting '"+c+"'"),this.instance=new this.EventBus(c,void 0,this.options.sockjsOptions),this.instance.onopen=function(){a.options.debugEnabled&&a.$log.debug("[Vert.x EB Stub] Connected"),angular.isFunction(a.onopen)&&a.onopen(),b.resolve()},this.instance.onclose=function(){a.options.debugEnabled&&a.$log.debug("[Vert.x EB Stub] Reconnect in "+a.options.sockjsReconnectInterval+"ms"),angular.isFunction(a.onclose)&&a.onclose(),a.instance=void 0,a.disconnectTimeoutEnabled?a.options.reconnectEnabled&&(
// automatic reconnect after timeout
a.options.debugEnabled&&a.$log.debug("[Vert.x EB Stub] Reconnect in "+a.options.sockjsReconnectInterval+"ms"),a.$timeout(function(){return a.connect()},a.options.sockjsReconnectInterval)):(
// reconnect required asap
a.options.debugEnabled&&a.$log.debug("[Vert.x EB Stub] Reconnect immediately"),a.disconnectTimeoutEnabled=!0,a.connect())},b.promise}},{key:"reconnect",value:function(){var a=arguments.length<=0||void 0===arguments[0]?!1:arguments[0];this.instance&&this.instance.readyState()===this.EventBus.OPEN?(a&&(this.disconnectTimeoutEnabled=!1),this.instance.close()):this.connect()}},{key:"close",value:function(){this.instance&&this.instance.close()}},{key:"login",value:function(a,b,c){if(this.instance){if(!this.instance.login)return this.$log.error("[Vert.x EB Stub] Attempted to call vertx.EventBus.login(), but that was not found. Are you using v3 already? Have a look at vertx.EventBusServiceProvider.useLoginInterceptor"),void c();this.instance.login(a,b,c)}}},{key:"send",value:function(a,b,c,d){this.instance&&this.instance.send(a,b,c,d)}},{key:"publish",value:function(a,b){this.instance&&this.instance.publish(a,b)}},{key:"registerHandler",value:function(a,b){var c=this;if(this.instance){this.instance.registerHandler(a,b);
// and return the deregister callback
var d=function(){c.unregisterHandler(a,b)};return d.displayName=i.moduleName+".wrapper.eventbus.registerHandler.deconstructor",d}}},{key:"unregisterHandler",value:function(a,b){this.instance&&this.instance.readyState()===this.EventBus.OPEN&&this.instance.unregisterHandler(a,b)}},{key:"readyState",value:function(){return this.instance?this.instance.readyState():this.EventBus.CLOSED}},{key:"getOptions",value:function(){
// clone options
return angular.extend({},this.options)}}]),b}(k["default"]);c["default"]=n},{"../../config.js":1,"./../support/ConnectionConfigHolder":12,"./BaseAdapter":5}],7:[function(a,b,c){"use strict";function d(a){return a&&a.__esModule?a:{"default":a}}function e(a,b){if(!(a instanceof b))throw new TypeError("Cannot call a class as a function")}function f(a,b){if(!a)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return!b||"object"!=typeof b&&"function"!=typeof b?a:b}function g(a,b){if("function"!=typeof b&&null!==b)throw new TypeError("Super expression must either be null or a function, not "+typeof b);a.prototype=Object.create(b&&b.prototype,{constructor:{value:a,enumerable:!1,writable:!0,configurable:!0}}),b&&(Object.setPrototypeOf?Object.setPrototypeOf(a,b):a.__proto__=b)}Object.defineProperty(c,"__esModule",{value:!0});var h=a("./BaseAdapter"),i=d(h),j=function(a){function b(a,c){e(this,b);
// actual EventBus type
var d=f(this,Object.getPrototypeOf(b).call(this,c));return d.EventBus=a,d}return g(b,a),b}(i["default"]);c["default"]=j},{"./BaseAdapter":5}],8:[function(a,b,c){"use strict";function d(a,b){if(!(a instanceof b))throw new TypeError("Cannot call a class as a function")}var e=function(){function a(a,b){for(var c=0;c<b.length;c++){var d=b[c];d.enumerable=d.enumerable||!1,d.configurable=!0,"value"in d&&(d.writable=!0),Object.defineProperty(a,d.key,d)}}return function(b,c,d){return c&&a(b.prototype,c),d&&a(b,d),b}}();Object.defineProperty(c,"__esModule",{value:!0});var f=a("../../config"),g=function(){function a(b,c){var e=this;d(this,a),this.delegate=b,this.$log=c,this.handlers=[],this.delegate.observe({afterEventbusConnected:function(){return e.afterEventbusConnected()}})}return e(a,[{key:"afterEventbusConnected",value:function(){for(var a in this.handlers){var b=this.handlers[a];if(b&&b.length){var c=!0,d=!1,e=void 0;try{for(var f,g=b[Symbol.iterator]();!(c=(f=g.next()).done);c=!0){var h=f.value;this.delegate.registerHandler(a,h)}}catch(i){d=!0,e=i}finally{try{!c&&g["return"]&&g["return"]()}finally{if(d)throw e}}}}}},{key:"registerHandler",value:function(a,b){var c=this;this.handlers[a]||(this.handlers[a]=[]),this.handlers[a].push(b);var d=null;this.delegate.isConnectionOpen()&&(this.delegate.registerHandler(a,b),d=function(){return c.delegate.unregisterHandler(a,b)});
// and return the deregister callback
var e=function(){
// Remove from internal map
if(d&&(d(),d=void 0),c.handlers[a]){var e=c.handlers[a].indexOf(b);e>-1&&c.handlers[a].splice(e,1),c.handlers[a].length<1&&(c.handlers[a]=void 0)}};return e.displayName=f.moduleName+".service.registerHandler.deconstructor",e}},{key:"on",value:function(a,b){return this.registerHandler(a,b)}},{key:"addListener",value:function(a,b){return this.registerHandler(a,b)}},{key:"unregisterHandler",value:function(a,b){
// Remove from internal map
if(this.handlers[a]){var c=this.handlers[a].indexOf(b);c>-1&&this.handlers[a].splice(c,1),this.handlers[a].length<1&&(this.handlers[a]=void 0)}
// Remove from real instance
this.delegate.isConnectionOpen()&&this.delegate.unregisterHandler(a,b)}},{key:"un",value:function(a,b){return this.unregisterHandler(a,b)}},{key:"removeListener",value:function(a,b){return this.unregisterHandler(a,b)}},{key:"send",value:function(a,b){var c=arguments.length<=2||void 0===arguments[2]?{}:arguments[2];
// FALLBACK: signature change since 2.0
// FALLBACK: signature change since 2.0
return angular.isObject(c)?this.delegate.send(a,b,c.timeout,c.expectReply):(this.$log.error(f.moduleName+": Signature of vertxEventBusService.send() has been changed!"),this.send(a,b,{timeout:void 0!==arguments[2]?arguments[2]:1e4,expectReply:void 0!==arguments[3]?arguments[3]:!0}))}},{key:"publish",value:function(a,b){return this.delegate.publish(a,b)}},{key:"emit",value:function(a,b){return this.publish(a,b)}},{key:"getConnectionState",value:function(){return this.delegate.getConnectionState()}},{key:"readyState",value:function(){return this.getConnectionState()}},{key:"isEnabled",value:function(){return this.delegate.isEnabled()}},{key:"isConnected",value:function(){return this.delegate.isConnected()}},{key:"login",value:function(a,b,c){return this.delegate.login(a,b,c)}}]),a}();c["default"]=g},{"../../config":1}],9:[function(a,b,c){"use strict";function d(a,b){if(!(a instanceof b))throw new TypeError("Cannot call a class as a function")}var e=function(){function a(a,b){for(var c=0;c<b.length;c++){var d=b[c];d.enumerable=d.enumerable||!1,d.configurable=!0,"value"in d&&(d.writable=!0),Object.defineProperty(a,d.key,d)}}return function(b,c,d){return c&&a(b.prototype,c),d&&a(b,d),b}}();Object.defineProperty(c,"__esModule",{value:!0});var f=function(){function a(){d(this,a)}return e(a,[{key:"getConnectionState",value:function(){return 3}},{key:"isConnectionOpen",value:function(){return!1}},{key:"isValidSession",value:function(){return!1}},{key:"isEnabled",value:function(){return!1}},{key:"isConnected",value:function(){return!1}},{key:"send",value:function(){}},{key:"publish",value:function(){}}]),a}();c["default"]=f},{}],10:[function(a,b,c){"use strict";function d(a){return a&&a.__esModule?a:{"default":a}}function e(a,b){if(!(a instanceof b))throw new TypeError("Cannot call a class as a function")}function f(a,b){if(!a)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return!b||"object"!=typeof b&&"function"!=typeof b?a:b}function g(a,b){if("function"!=typeof b&&null!==b)throw new TypeError("Super expression must either be null or a function, not "+typeof b);a.prototype=Object.create(b&&b.prototype,{constructor:{value:a,enumerable:!1,writable:!0,configurable:!0}}),b&&(Object.setPrototypeOf?Object.setPrototypeOf(a,b):a.__proto__=b)}var h=function(){function a(a,b){for(var c=0;c<b.length;c++){var d=b[c];d.enumerable=d.enumerable||!1,d.configurable=!0,"value"in d&&(d.writable=!0),Object.defineProperty(a,d.key,d)}}return function(b,c,d){return c&&a(b.prototype,c),d&&a(b,d),b}}();Object.defineProperty(c,"__esModule",{value:!0});var i=a("../../../config"),j=a("./../../support/Queue"),k=d(j),l=a("./../../support/SimpleMap"),m=d(l),n=a("./BaseDelegate"),o=d(n),p=function(a){function b(a,c,d,g,h,i){e(this,b);var j=i.enabled,l=i.debugEnabled,n=i.prefix,o=i.sockjsStateInterval,p=i.messageBuffer,q=i.loginRequired,r=i.loginInterceptor,s=f(this,Object.getPrototypeOf(b).call(this));
// internal store of buffered messages
// internal map of callbacks
// asap
return s.$rootScope=a,s.$interval=c,s.$log=d,s.$q=g,s.eventBus=h,s.options={enabled:j,debugEnabled:l,prefix:n,sockjsStateInterval:o,messageBuffer:p,loginRequired:q},s.loginInterceptor=r,s.connectionState=s.eventBus.EventBus.CLOSED,s.states={connected:!1,validSession:!1},s.observers=[],s.messageQueue=new k["default"](s.options.messageBuffer),s.callbackMap=new m["default"],s.initialize(),s}
// internal
return g(b,a),h(b,[{key:"initialize",value:function(){var a=this;this.eventBus.onopen=function(){return a.onEventbusOpen()},this.eventBus.onclose=function(){return a.onEventbusClose()};
// Update the current connection state periodically.
var b=function(){return a.getConnectionState(!0)};b.displayName="connectionIntervalCheck",this.$interval(function(){return b()},this.options.sockjsStateInterval)}},{key:"onEventbusOpen",value:function(){var a=!1;// explicitly
// consume message queue?
if(this.getConnectionState(!0),this.states.connected||(this.states.connected=!0,a=!0),
// Ensure all events will be re-attached
this.afterEventbusConnected(),
// Everything is online and registered again, let's notify everybody
a&&this.$rootScope.$broadcast(this.options.prefix+"system.connected"),this.$rootScope.$digest(),this.options.messageBuffer&&this.messageQueue.size()){for(;this.messageQueue.size();){var b=this.messageQueue.first();angular.isFunction(b)&&b()}this.$rootScope.$digest()}}},{key:"onEventbusClose",value:function(){this.getConnectionState(!0),this.states.connected&&(this.states.connected=!1,this.$rootScope.$broadcast(this.options.prefix+"system.disconnected"))}},{key:"observe",value:function(a){this.observers.push(a)}},{key:"afterEventbusConnected",value:function(){var a=!0,b=!1,c=void 0;try{for(var d,e=this.observers[Symbol.iterator]();!(a=(d=e.next()).done);a=!0){var f=d.value;angular.isFunction(f.afterEventbusConnected)&&f.afterEventbusConnected()}}catch(g){b=!0,c=g}finally{try{!a&&e["return"]&&e["return"]()}finally{if(b)throw c}}}},{key:"registerHandler",value:function(a,b){var c=this;if(angular.isFunction(b)){this.options.debugEnabled&&this.$log.debug("[Vert.x EB Service] Register handler for "+a);var d=function(a,d){b(a,d),c.$rootScope.$digest()};return d.displayName=i.moduleName+".service.delegate.live.registerHandler.callbackWrapper",this.callbackMap.put(b,d),this.eventBus.registerHandler(a,d)}}},{key:"unregisterHandler",value:function(a,b){angular.isFunction(b)&&(this.options.debugEnabled&&this.$log.debug("[Vert.x EB Service] Unregister handler for "+a),this.eventBus.unregisterHandler(a,this.callbackMap.get(b)),this.callbackMap.remove(b))}},{key:"send",value:function(a,b){var c=this,d=arguments.length<=2||void 0===arguments[2]?1e4:arguments[2],e=arguments.length<=3||void 0===arguments[3]?!0:arguments[3],f=this.$q.defer(),g=function(){e?!function(){
// Register timeout for promise rejecting
var e=c.$interval(function(){c.options.debugEnabled&&c.$log.debug("[Vert.x EB Service] send('"+a+"') timed out"),f.reject()},d,1);
// Send message
// TODO after dropping support for Vert.x < v3, this can be enriched with failureHandler
c.eventBus.send(a,b,function(a){c.$interval.cancel(e),// because it's resolved
f.resolve(a)})}():(c.eventBus.send(a,b),f.resolve())};return g.displayName=i.moduleName+".service.delegate.live.send.next",this.ensureOpenAuthConnection(g)||f.reject(),f.promise}},{key:"publish",value:function(a,b){var c=this;return this.ensureOpenAuthConnection(function(){return c.eventBus.publish(a,b)})}},{key:"login",value:function(){var a=arguments.length<=0||void 0===arguments[0]?this.options.username:arguments[0],b=this,c=arguments.length<=1||void 0===arguments[1]?this.options.password:arguments[1],d=arguments.length<=2||void 0===arguments[2]?5e3:arguments[2],e=this.$q.defer(),f=function(a){a=a||{},"ok"===a.status?(b.states.validSession=!0,e.resolve(a),b.$rootScope.$broadcast(b.options.prefix+"system.login.succeeded",{status:a.status})):(b.states.validSession=!1,e.reject(a),b.$rootScope.$broadcast(b.options.prefix+"system.login.failed",{status:a.status}))};if(f.displayName=i.moduleName+".service.delegate.live.login.next",this.loginInterceptor){
// reference to a direct sender
var g=function(a,c,d){b.eventBus.send(a,c,d)};this.loginInterceptor(g,a,c,f)}else
// Legacy way like Vert.x 2
this.eventBus.login(a,c,f);return this.$interval(function(){return e.reject()},d,1),e.promise}},{key:"ensureOpenConnection",value:function(a){return this.isConnectionOpen()?(a(),!0):this.options.messageBuffer?(this.messageQueue.push(a),!0):!1}},{key:"ensureOpenAuthConnection",value:function(a){var b=this;if(this.options.loginRequired){var c=function(){
// ignore this message
return b.states.validSession?(a(),!0):(b.options.debugEnabled&&b.$log.debug("[Vert.x EB Service] Message was not sent because login is required"),!1)};return c.displayName=i.moduleName+".service.delegate.live.ensureOpenAuthConnection.fnWrapper",this.ensureOpenConnection(c)}
// easy: no login required
return this.ensureOpenConnection(a)}},{key:"getConnectionState",value:function(a){return this.options.enabled?a&&(this.connectionState=this.eventBus.readyState()):this.connectionState=this.eventBus.EventBus.CLOSED,this.connectionState}},{key:"isConnectionOpen",value:function(){return this.getConnectionState()===this.eventBus.EventBus.OPEN}},{key:"isValidSession",value:function(){return this.states.validSession}},{key:"isConnected",value:function(){return this.states.connected}},{key:"isEnabled",value:function(){return this.options.enabled}},{key:"getMessageQueueLength",value:function(){return this.messageQueue.size()}}]),b}(o["default"]);c["default"]=p},{"../../../config":1,"./../../support/Queue":13,"./../../support/SimpleMap":14,"./BaseDelegate":9}],11:[function(a,b,c){"use strict";function d(a){return a&&a.__esModule?a:{"default":a}}function e(a,b){if(!(a instanceof b))throw new TypeError("Cannot call a class as a function")}function f(a,b){if(!a)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return!b||"object"!=typeof b&&"function"!=typeof b?a:b}function g(a,b){if("function"!=typeof b&&null!==b)throw new TypeError("Super expression must either be null or a function, not "+typeof b);a.prototype=Object.create(b&&b.prototype,{constructor:{value:a,enumerable:!1,writable:!0,configurable:!0}}),b&&(Object.setPrototypeOf?Object.setPrototypeOf(a,b):a.__proto__=b)}Object.defineProperty(c,"__esModule",{value:!0});var h=a("./BaseDelegate"),i=d(h),j=function(a){function b(){return e(this,b),f(this,Object.getPrototypeOf(b).apply(this,arguments))}return g(b,a),b}(i["default"]);c["default"]=j},{"./BaseDelegate":9}],12:[function(a,b,c){"use strict";function d(a,b){if(!(a instanceof b))throw new TypeError("Cannot call a class as a function")}var e=function(){function a(a,b){for(var c=0;c<b.length;c++){var d=b[c];d.enumerable=d.enumerable||!1,d.configurable=!0,"value"in d&&(d.writable=!0),Object.defineProperty(a,d.key,d)}}return function(b,c,d){return c&&a(b.prototype,c),d&&a(b,d),b}}();Object.defineProperty(c,"__esModule",{value:!0});var f=function(){function a(b){d(this,a);var c=b.urlServer,e=b.urlPath;this._urlServer=c,this._urlPath=e}return e(a,[{key:"urlServer",get:function(){return this._urlServer}},{key:"urlPath",get:function(){return this._urlPath}}]),a}();c["default"]=f},{}],13:[function(a,b,c){"use strict";function d(a,b){if(!(a instanceof b))throw new TypeError("Cannot call a class as a function")}var e=function(){function a(a,b){for(var c=0;c<b.length;c++){var d=b[c];d.enumerable=d.enumerable||!1,d.configurable=!0,"value"in d&&(d.writable=!0),Object.defineProperty(a,d.key,d)}}return function(b,c,d){return c&&a(b.prototype,c),d&&a(b,d),b}}();Object.defineProperty(c,"__esModule",{value:!0});/*
 Simple queue implementation

 FIFO: #push() + #first()
 LIFO: #push() + #last()
 */
var f=function(){function a(){d(this,a);var b=arguments.length<=0||void 0===arguments[0]?10:arguments[0];this.maxSize=b,this.items=[]}return e(a,[{key:"push",value:function(a){return this.items.push(a),this.recalibrateBufferSize()}},{key:"recalibrateBufferSize",value:function(){for(;this.items.length>this.maxSize;)this.first();return this}},{key:"last",value:function(){return this.items.pop()}},{key:"first",value:function(){return this.items.shift(0)}},{key:"size",value:function(){return this.items.length}}]),a}();c["default"]=f},{}],14:[function(a,b,c){"use strict";function d(a,b){if(!(a instanceof b))throw new TypeError("Cannot call a class as a function")}var e=function(){function a(a,b){for(var c=0;c<b.length;c++){var d=b[c];d.enumerable=d.enumerable||!1,d.configurable=!0,"value"in d&&(d.writable=!0),Object.defineProperty(a,d.key,d)}}return function(b,c,d){return c&&a(b.prototype,c),d&&a(b,d),b}}();Object.defineProperty(c,"__esModule",{value:!0});/*
 Simple Map implementation

 This implementation allows usage of non serializable keys for values.
 */
var f=function(){function a(){d(this,a),this.clear()}
// Stores the value under the key.
// Chainable
return e(a,[{key:"put",value:function(a,b){var c=this._indexForKey(a);return c>-1?this.values[c]=b:(this.keys.push(a),this.values.push(b)),this}},{key:"get",value:function(a){var b=this._indexForKey(a);return b>-1?this.values[b]:void 0}},{key:"containsKey",value:function(a){var b=this._indexForKey(a);return b>-1}},{key:"containsValue",value:function(a){var b=this._indexForValue(a);return b>-1}},{key:"remove",value:function(a){var b=this._indexForKey(a);b>-1&&(this.keys[b]=void 0,this.values[b]=void 0)}},{key:"clear",value:function(){return this.keys=[],this.values=[],this}},{key:"_indexForKey",value:function(a){for(var b in this.keys)if(a===this.keys[b])return b;return-1}},{key:"_indexForValue",value:function(a){for(var b in this.values)if(a===this.values[b])return b;return-1}}]),a}();c["default"]=f},{}],15:[function(a,b,c){"use strict";function d(a){return a&&a.__esModule?a:{"default":a}}Object.defineProperty(c,"__esModule",{value:!0});var e=a("./config"),f=a("./lib/VertxEventBusWrapperProvider"),g=d(f),h=a("./lib/VertxEventBusServiceProvider"),i=d(h);/**
 * @ngdoc overview
 * @module knalli.angular-vertxbus
 * @name knalli.angular-vertxbus
 * @description
 *
 * Client side library using VertX Event Bus as an Angular Service module
 *
 * You have to define the module dependency, this module is named `knalli.angular-vertxbus`.
 *
 * <pre>
 *   angular.module('app', ['knalli.angular-vertxbus'])
 *     .controller('MyCtrl', function(vertxEventBus, vertxEventBusService) {
 *
 *       // using the EventBus directly
 *       vertxEventBus.send('my.address', {data: 123}, function (reply) {
 *         // your reply comes here
 *       });
 *
 *       // using the service
 *       vertxEventBusService.send('my.address', {data: 123}, {timeout: 500})
 *         .then(function (reply) {
 *           // your reply comes here
 *         })
 *         .catch(function (err) {
 *           // something went wrong, no connection, no login, timed out, or so
 *         });
 *     });
 * </pre>
 *
 * The module itself provides following components:
 * - {@link knalli.angular-vertxbus.vertxEventBus vertxEventBus}: a low level wrapper around `vertx.EventBus`
 * - {@link knalli.angular-vertxbus.vertxEventBusService vertxEventBusService}: a high level service around the wrapper
 *
 * While the wrapper only provides one single instance (even on reconnects), the service supports automatically
 * reconnect management, authorization and a clean promise based api.
 *
 * If you are looking for a low integration of `vertxbus.EventBus` as an AngularJS component, the wrapper will be your
 * choice. The only difference (and requirement for the wrapper actually) is how it will manage and replace the
 * underlying instance of the current `vertx.EventBus`.
 *
 * However, if you are looking for a simple, clean and promised based high api, the service is much better you.
 */
c["default"]=angular.module(e.moduleName,["ng"]).provider("vertxEventBus",g["default"]).provider("vertxEventBusService",i["default"]).name},{"./config":1,"./lib/VertxEventBusServiceProvider":3,"./lib/VertxEventBusWrapperProvider":4}]},{},[2]);