{"version":3,"sources":["webpack:///webpack/universalModuleDefinition","webpack:///dist/angular-vertxbus.min.js","webpack:///webpack/bootstrap 767704362563894bafc3","webpack:///./src/index.js","webpack:///./src/module.js","webpack:///./src/config.js","webpack:///./src/lib/VertxEventBusWrapperProvider.js","webpack:///./src/lib/adapter/EventBusAdapter.js","webpack:///./src/lib/adapter/BaseAdapter.js","webpack:///./src/lib/support/ConnectionConfigHolder.js","webpack:///./src/lib/adapter/NoopAdapter.js","webpack:///./src/lib/VertxEventBusServiceProvider.js","webpack:///./src/lib/service/delegate/EventBusDelegate.js","webpack:///./src/lib/support/Queue.js","webpack:///./src/lib/support/SimpleMap.js","webpack:///./src/lib/service/delegate/BaseDelegate.js","webpack:///./src/lib/service/delegate/NoopDelegate.js","webpack:///./src/lib/service/Delegator.js"],"names":["root","factory","exports","module","require","define","amd","a","i","this","__WEBPACK_EXTERNAL_MODULE_8__","modules","__webpack_require__","moduleId","installedModules","id","loaded","call","m","c","p","_interopRequireDefault","obj","__esModule","default","Object","defineProperty","value","_module","_module2","_config","_VertxEventBusWrapperProvider","_VertxEventBusWrapperProvider2","_VertxEventBusServiceProvider","_VertxEventBusServiceProvider2","angular","moduleName","provider","name","_EventBusAdapter","_EventBusAdapter2","_NoopAdapter","_NoopAdapter2","_ConnectionConfigHolder","_ConnectionConfigHolder2","_vertxEventbus","_vertxEventbus2","DEFAULTS","enabled","debugEnabled","initialConnectEnabled","urlServer","location","protocol","hostname","port","urlPath","reconnectEnabled","sockjsReconnectInterval","sockjsOptions","VertxEventBusWrapperProvider","_this","options","extend","enable","arguments","length","undefined","disableAutoConnect","useDebug","useUrlServer","useUrlPath","useReconnect","useSockJsReconnectInterval","useSockJsOptions","$get","$timeout","$log","$q","instanceOptions","debug","connectionConfig","$inject","_classCallCheck","instance","Constructor","TypeError","_possibleConstructorReturn","self","ReferenceError","_inherits","subClass","superClass","prototype","create","constructor","enumerable","writable","configurable","setPrototypeOf","__proto__","_typeof","Symbol","iterator","_createClass","defineProperties","target","props","descriptor","key","protoProps","staticProps","_BaseAdapter2","_BaseAdapter3","EventBusAdapter","_BaseAdapter","EventBus","_ref","getPrototypeOf","disconnectTimeoutEnabled","applyDefaultHeaders","connect","_this2","deferred","defer","url","onopen","isFunction","resolve","onclose","onerror","message","promise","immediately","state","OPEN","close","address","headers","replyHandler","mergedHeaders","getMergedHeaders","send","publish","handler","_this3","_ret","registerHandler","deconstructor","unregisterHandler","displayName","v","CLOSED","get","readyState","BaseAdapter","reject","defaultHeaders","ConnectionConfigHolder","_urlServer","_urlPath","NoopAdapter","_EventBusDelegate","_EventBusDelegate2","_NoopDelegate","_NoopDelegate2","_Delegator","_Delegator2","authRequired","prefix","sockjsStateInterval","messageBuffer","VertxEventBusServiceProvider","usePrefix","useSockJsStateInterval","useMessageBuffer","authHandler","$rootScope","$interval","vertxEventBus","$injector","getOptions","_Queue","_Queue2","_SimpleMap","_SimpleMap2","_BaseDelegate2","_BaseDelegate3","EventBusDelegate","_BaseDelegate","eventBus","isString","e","connectionState","states","connected","authorized","observers","messageQueue","callbackMap","initialize","onEventbusOpen","onEventbusClose","connectionIntervalCheck","getConnectionState","connectionStateFlipped","afterEventbusConnected","$broadcast","$digest","size","fn","first","observer","push","_iteratorNormalCompletion","_didIteratorError","_iteratorError","_step","_iterator","next","done","err","callback","callbackWrapper","_ref2","replyTo","body","put","remove","_this4","timeout","expectReply","timer","reply","cancel","ensureOpenAuthConnection","then","_this5","isConnectionOpen","inQueue","_this6","fnWrapper","onValidAuth","onInvalidAuth","authResult","ensureOpenConnection","immediate","Queue","maxSize","items","item","recalibrateBufferSize","pop","shift","SimpleMap","clear","idx","_indexForKey","values","keys","_indexForValue","BaseDelegate","NoopDelegate","apply","Delegator","delegate","handlers","observe","hasOwnProperty","callbacks","_step$value","unregisterFn","index","indexOf","splice","isEnabled","isConnected","isAuthorized","getMessageQueueLength"],"mappings":"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","file":"dist/angular-vertxbus.min.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory(require(\"vertx-eventbus\"));\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([\"vertx-eventbus\"], factory);\n\telse {\n\t\tvar a = typeof exports === 'object' ? factory(require(\"vertx-eventbus\")) : factory(root[\"EventBus\"]);\n\t\tfor(var i in a) (typeof exports === 'object' ? exports : root)[i] = a[i];\n\t}\n})(this, function(__WEBPACK_EXTERNAL_MODULE_8__) {\nreturn \n\n\n/** WEBPACK FOOTER **\n ** webpack/universalModuleDefinition\n **/","/*! angular-vertxbus - v6.1.1 - 2016-08-21\n * http://github.com/knalli/angular-vertxbus\n * Copyright (c) 2016 Jan Philipp\n * @license MIT */\n(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory(require(\"vertx-eventbus\"));\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([\"vertx-eventbus\"], factory);\n\telse {\n\t\tvar a = typeof exports === 'object' ? factory(require(\"vertx-eventbus\")) : factory(root[\"EventBus\"]);\n\t\tfor(var i in a) (typeof exports === 'object' ? exports : root)[i] = a[i];\n\t}\n})(this, function(__WEBPACK_EXTERNAL_MODULE_8__) {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n\n\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\n\tvar _module = __webpack_require__(1);\n\n\tvar _module2 = _interopRequireDefault(_module);\n\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n\texports.default = _module2.default;\n\n/***/ },\n/* 1 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\n\tvar _config = __webpack_require__(2);\n\n\tvar _VertxEventBusWrapperProvider = __webpack_require__(3);\n\n\tvar _VertxEventBusWrapperProvider2 = _interopRequireDefault(_VertxEventBusWrapperProvider);\n\n\tvar _VertxEventBusServiceProvider = __webpack_require__(9);\n\n\tvar _VertxEventBusServiceProvider2 = _interopRequireDefault(_VertxEventBusServiceProvider);\n\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n\t/**\n\t * @ngdoc overview\n\t * @module knalli.angular-vertxbus\n\t * @name knalli.angular-vertxbus\n\t * @description\n\t *\n\t * Client side library using VertX Event Bus as an Angular Service module\n\t *\n\t * You have to define the module dependency, this module is named `knalli.angular-vertxbus`.\n\t *\n\t * <pre>\n\t *   angular.module('app', ['knalli.angular-vertxbus'])\n\t *     .controller('MyCtrl', function(vertxEventBus, vertxEventBusService) {\n\t *\n\t *       // using the EventBus directly\n\t *       vertxEventBus.send('my.address', {data: 123}, function (reply) {\n\t *         // your reply comes here\n\t *       });\n\t *\n\t *       // using the service\n\t *       vertxEventBusService.send('my.address', {data: 123}, {timeout: 500})\n\t *         .then(function (reply) {\n\t *           // your reply comes here\n\t *         })\n\t *         .catch(function (err) {\n\t *           // something went wrong, no connection, no login, timed out, or so\n\t *         });\n\t *     });\n\t * </pre>\n\t *\n\t * The module itself provides following components:\n\t * - {@link knalli.angular-vertxbus.vertxEventBus vertxEventBus}: a low level wrapper around `vertx.EventBus`\n\t * - {@link knalli.angular-vertxbus.vertxEventBusService vertxEventBusService}: a high level service around the wrapper\n\t *\n\t * While the wrapper only provides one single instance (even on reconnects), the service supports automatically\n\t * reconnect management, authorization and a clean promise based api.\n\t *\n\t * If you are looking for a low integration of `vertxbus.EventBus` as an AngularJS component, the wrapper will be your\n\t * choice. The only difference (and requirement for the wrapper actually) is how it will manage and replace the\n\t * underlying instance of the current `vertx.EventBus`.\n\t *\n\t * However, if you are looking for a simple, clean and promised based high api, the service is much better you.\n\t */\n\texports.default = angular.module(_config.moduleName, ['ng']).provider('vertxEventBus', _VertxEventBusWrapperProvider2.default).provider('vertxEventBusService', _VertxEventBusServiceProvider2.default).name;\n\n/***/ },\n/* 2 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\tvar moduleName = 'knalli.angular-vertxbus';\n\n\texports.moduleName = moduleName;\n\n/***/ },\n/* 3 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\n\tvar _EventBusAdapter = __webpack_require__(4);\n\n\tvar _EventBusAdapter2 = _interopRequireDefault(_EventBusAdapter);\n\n\tvar _NoopAdapter = __webpack_require__(7);\n\n\tvar _NoopAdapter2 = _interopRequireDefault(_NoopAdapter);\n\n\tvar _ConnectionConfigHolder = __webpack_require__(6);\n\n\tvar _ConnectionConfigHolder2 = _interopRequireDefault(_ConnectionConfigHolder);\n\n\tvar _vertxEventbus = __webpack_require__(8);\n\n\tvar _vertxEventbus2 = _interopRequireDefault(_vertxEventbus);\n\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n\t/**\n\t * @ngdoc service\n\t * @module knalli.angular-vertxbus\n\t * @name knalli.angular-vertxbus.vertxEventBusProvider\n\t * @description\n\t * An AngularJS wrapper for projects using the VertX Event Bus\n\t */\n\n\tvar DEFAULTS = {\n\t  enabled: true,\n\t  debugEnabled: false,\n\t  initialConnectEnabled: true,\n\t  urlServer: location.protocol + '//' + location.hostname + (function () {\n\t    if (location.port) {\n\t      return ':' + location.port;\n\t    }\n\t  }() || ''),\n\t  urlPath: '/eventbus',\n\t  reconnectEnabled: true,\n\t  sockjsReconnectInterval: 10000,\n\t  sockjsOptions: {}\n\t};\n\n\tvar VertxEventBusWrapperProvider = function VertxEventBusWrapperProvider() {\n\t  var _this = this;\n\n\t  // options (globally, application-wide)\n\t  var options = angular.extend({}, DEFAULTS);\n\n\t  /**\n\t   * @ngdoc method\n\t   * @module knalli.angular-vertxbus\n\t   * @methodOf knalli.angular-vertxbus.vertxEventBusProvider\n\t   * @name .#enable\n\t   *\n\t   * @description\n\t   * Enables or disables the service. This setup is immutable.\n\t   *\n\t   * @param {boolean} [value=true] service is enabled on startup\n\t   * @returns {object} this\n\t   */\n\t  this.enable = function () {\n\t    var value = arguments.length <= 0 || arguments[0] === undefined ? DEFAULTS.enabled : arguments[0];\n\n\t    options.enabled = value === true;\n\t    return _this;\n\t  };\n\n\t  /**\n\t   * @ngdoc method\n\t   * @module knalli.angular-vertxbus\n\t   * @methodOf knalli.angular-vertxbus.vertxEventBusProvider\n\t   * @name .#disableAutoConnect\n\t   *\n\t   * @description\n\t   * Disables the auto connection feature.\n\t   *\n\t   * This feature will be only available if `enable == true`.\n\t   *\n\t   * @param {boolean} [value=true] auto connect on startup\n\t   * @returns {object} this\n\t   */\n\t  this.disableAutoConnect = function () {\n\t    options.initialConnectEnabled = false;\n\t    return _this;\n\t  };\n\n\t  /**\n\t   * @ngdoc method\n\t   * @module knalli.angular-vertxbus\n\t   * @methodOf knalli.angular-vertxbus.vertxEventBusProvider\n\t   * @name .#useDebug\n\t   *\n\t   * @description\n\t   * Enables a verbose mode in which certain events will be logged to `$log`.\n\t   *\n\t   * @param {boolean} [value=false] verbose mode (using `$log`)\n\t   * @returns {object} this\n\t   */\n\t  this.useDebug = function () {\n\t    var value = arguments.length <= 0 || arguments[0] === undefined ? DEFAULTS.debugEnabled : arguments[0];\n\n\t    options.debugEnabled = value === true;\n\t    return _this;\n\t  };\n\n\t  /**\n\t   * @ngdoc method\n\t   * @module knalli.angular-vertxbus\n\t   * @methodOf knalli.angular-vertxbus.vertxEventBusProvider\n\t   * @name .#useUrlServer\n\t   *\n\t   * @description\n\t   * Overrides the url part \"server\" for connecting. The default is based on\n\t   * - `location.protocol`\n\t   * - `location.hostname`\n\t   * - `location.port`\n\t   *\n\t   * i.e. `http://domain.tld` or `http://domain.tld:port`\n\t   *\n\t   * @param {boolean} [value=$computed] server to connect (default based on `location.protocol`, `location.hostname` and `location.port`)\n\t   * @returns {object} this\n\t   */\n\t  this.useUrlServer = function () {\n\t    var value = arguments.length <= 0 || arguments[0] === undefined ? DEFAULTS.urlServer : arguments[0];\n\n\t    options.urlServer = value;\n\t    return _this;\n\t  };\n\n\t  /**\n\t   * @ngdoc method\n\t   * @module knalli.angular-vertxbus\n\t   * @methodOf knalli.angular-vertxbus.vertxEventBusProvider\n\t   * @name .#useUrlPath\n\t   *\n\t   * @description\n\t   * Overrides the url part \"path\" for connection.\n\t   *\n\t   * @param {boolean} [value='/eventbus'] path to connect\n\t   * @returns {object} this\n\t   */\n\t  this.useUrlPath = function () {\n\t    var value = arguments.length <= 0 || arguments[0] === undefined ? DEFAULTS.urlPath : arguments[0];\n\n\t    options.urlPath = value;\n\t    return _this;\n\t  };\n\n\t  /**\n\t   * @ngdoc method\n\t   * @module knalli.angular-vertxbus\n\t   * @methodOf knalli.angular-vertxbus.vertxEventBusProvider\n\t   * @name .#useReconnect\n\t   *\n\t   * @description\n\t   * Enables or disables the automatic reconnect handling.\n\t   *\n\t   * @param {boolean} [value=true] if a disconnect was being noted, a reconnect will be enforced automatically\n\t   * @returns {object} this\n\t   */\n\t  this.useReconnect = function () {\n\t    var value = arguments.length <= 0 || arguments[0] === undefined ? DEFAULTS.reconnectEnabled : arguments[0];\n\n\t    options.reconnectEnabled = value;\n\t    return _this;\n\t  };\n\n\t  /**\n\t   * @ngdoc method\n\t   * @module knalli.angular-vertxbus\n\t   * @methodOf knalli.angular-vertxbus.vertxEventBusProvider\n\t   * @name .#useSockJsReconnectInterval\n\t   *\n\t   * @description\n\t   * Overrides the timeout for reconnecting after a disconnect was found.\n\t   *\n\t   * @param {boolean} [value=10000] time between a disconnect and the next try to reconnect (in ms)\n\t   * @returns {object} this\n\t   */\n\t  this.useSockJsReconnectInterval = function () {\n\t    var value = arguments.length <= 0 || arguments[0] === undefined ? DEFAULTS.sockjsReconnectInterval : arguments[0];\n\n\t    options.sockjsReconnectInterval = value;\n\t    return _this;\n\t  };\n\n\t  /**\n\t   * @ngdoc method\n\t   * @module knalli.angular-vertxbus\n\t   * @methodOf knalli.angular-vertxbus.vertxEventBusProvider\n\t   * @name .#useSockJsOptions\n\t   *\n\t   * @description\n\t   * Sets additional params for the `SockJS` instance.\n\t   *\n\t   * Internally, it will be applied (as `options`) like `new SockJS(url, undefined, options)`.\n\t   *\n\t   * @param {boolean} [value={}]  optional params for raw SockJS options\n\t   * @returns {object} this\n\t   */\n\t  this.useSockJsOptions = function () {\n\t    var value = arguments.length <= 0 || arguments[0] === undefined ? DEFAULTS.sockjsOptions : arguments[0];\n\n\t    options.sockjsOptions = value;\n\t    return _this;\n\t  };\n\n\t  /**\n\t   * @ngdoc service\n\t   * @module knalli.angular-vertxbus\n\t   * @name knalli.angular-vertxbus.vertxEventBus\n\t   * @description\n\t   * A stub representing the Vert.x EventBus (core functionality)\n\t   *\n\t   * Because the Event Bus cannot handle a reconnect (because of the underlaying SockJS), a\n\t   * new instance of the bus have to be created.\n\t   * This stub ensures only one object holding the current active instance of the bus.\n\t   *\n\t   * The stub supports theses Vert.x Event Bus APIs:\n\t   *  - {@link knalli.angular-vertxbus.vertxEventBus#methods_close close()}\n\t   *  - {@link knalli.angular-vertxbus.vertxEventBus#methods_send send(address, message, handler)}\n\t   *  - {@link knalli.angular-vertxbus.vertxEventBus#methods_publish publish(address, message)}\n\t   *  - {@link knalli.angular-vertxbus.vertxEventBus#methods_registerHandler registerHandler(adress, handler)}\n\t   *  - {@link knalli.angular-vertxbus.vertxEventBus#methods_unregisterHandler unregisterHandler(address, handler)}\n\t   *  - {@link knalli.angular-vertxbus.vertxEventBus#methods_readyState readyState()}\n\t   *\n\t   * Furthermore, the stub supports theses extra APIs:\n\t   *  - {@link knalli.angular-vertxbus.vertxEventBus#methods_reconnect reconnect()}\n\t   *\n\t   * @requires $timeout\n\t   * @requires $log\n\t   */\n\t  /* @ngInject */\n\t  this.$get = function ($timeout, $log, $q) {\n\t    // Current options (merged defaults with application-wide settings)\n\t    var instanceOptions = angular.extend({}, DEFAULTS, options);\n\t    if (instanceOptions.enabled && _vertxEventbus2.default) {\n\t      if (instanceOptions.debugEnabled) {\n\t        $log.debug('[Vert.x EB Stub] Enabled');\n\t      }\n\n\t      // aggregate server connection params\n\t      instanceOptions.connectionConfig = new _ConnectionConfigHolder2.default({\n\t        urlServer: instanceOptions.urlServer,\n\t        urlPath: instanceOptions.urlPath\n\t      });\n\t      delete instanceOptions.urlServer;\n\t      delete instanceOptions.urlPath;\n\n\t      return new _EventBusAdapter2.default(_vertxEventbus2.default, $timeout, $log, $q, instanceOptions);\n\t    } else {\n\t      if (instanceOptions.debugEnabled) {\n\t        $log.debug('[Vert.x EB Stub] Disabled');\n\t      }\n\t      return new _NoopAdapter2.default(_vertxEventbus2.default, $q);\n\t    }\n\t  };\n\t  this.$get.$inject = [\"$timeout\", \"$log\", \"$q\"];\n\t};\n\n\texports.default = VertxEventBusWrapperProvider;\n\n/***/ },\n/* 4 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\n\tvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol ? \"symbol\" : typeof obj; };\n\n\tvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\n\tvar _config = __webpack_require__(2);\n\n\tvar _BaseAdapter2 = __webpack_require__(5);\n\n\tvar _BaseAdapter3 = _interopRequireDefault(_BaseAdapter2);\n\n\tvar _ConnectionConfigHolder = __webpack_require__(6);\n\n\tvar _ConnectionConfigHolder2 = _interopRequireDefault(_ConnectionConfigHolder);\n\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n\tfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\n\tfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\n\t/**\n\t * @ngdoc service\n\t * @module global\n\t * @name global.EventBus\n\t *\n\t * @description\n\t * This is the interface of `EventBus`. It is not included.\n\t */\n\n\t/**\n\t * @ngdoc method\n\t * @module global\n\t * @methodOf global.EventBus\n\t * @name .#close\n\t */\n\n\t/**\n\t * @ngdoc method\n\t * @module global\n\t * @methodOf global.EventBus\n\t * @name .#send\n\t *\n\t * @param {string} address target address\n\t * @param {object} message payload message\n\t * @param {object=} headers headers\n\t * @param {function=} replyHandler optional callback\n\t * @param {function=} failureHandler optional callback\n\t */\n\n\t/**\n\t * @ngdoc method\n\t * @module global\n\t * @methodOf global.EventBus\n\t * @name .#publish\n\t *\n\t * @param {string} address target address\n\t * @param {object} message payload message\n\t * @param {object=} headers headers\n\t */\n\n\t/**\n\t * @ngdoc method\n\t * @module global\n\t * @methodOf global.EventBus\n\t * @name .#registerHandler\n\t *\n\t * @param {string} address target address\n\t * @param {function} handler callback handler\n\t * @param {object=} headers headers\n\t */\n\n\t/**\n\t * @ngdoc method\n\t * @module global\n\t * @methodOf global.EventBus\n\t * @name .#unregisterHandler\n\t *\n\t * @param {string} address target address\n\t * @param {function} handler callback handler to be removed\n\t * @param {object=} headers headers\n\t */\n\n\t/**\n\t * @ngdoc property\n\t * @module global\n\t * @propertyOf global.EventBus\n\t * @name .#onopen\n\t * @description\n\t * Defines the callback called on opening the connection.\n\t */\n\n\t/**\n\t * @ngdoc property\n\t * @module global\n\t * @propertyOf global.EventBus\n\t * @name .#onclose\n\t * @description\n\t * Defines the callback called on closing the connection.\n\t */\n\n\t/**\n\t * @ngdoc property\n\t * @module global\n\t * @propertyOf global.EventBus\n\t * @name .#onerror\n\t * @description\n\t * Defines the callback called on any error.\n\t */\n\n\tvar EventBusAdapter = function (_BaseAdapter) {\n\t  _inherits(EventBusAdapter, _BaseAdapter);\n\n\t  function EventBusAdapter(EventBus, $timeout, $log, $q, _ref) {\n\t    var enabled = _ref.enabled;\n\t    var debugEnabled = _ref.debugEnabled;\n\t    var initialConnectEnabled = _ref.initialConnectEnabled;\n\t    var connectionConfig = _ref.connectionConfig;\n\t    var reconnectEnabled = _ref.reconnectEnabled;\n\t    var sockjsReconnectInterval = _ref.sockjsReconnectInterval;\n\t    var sockjsOptions = _ref.sockjsOptions;\n\n\t    _classCallCheck(this, EventBusAdapter);\n\n\t    // actual EventBus type\n\t    var _this = _possibleConstructorReturn(this, Object.getPrototypeOf(EventBusAdapter).call(this, $q));\n\n\t    _this.EventBus = EventBus;\n\t    _this.$timeout = $timeout;\n\t    _this.$log = $log;\n\t    _this.$q = $q;\n\t    _this.options = {\n\t      enabled: enabled,\n\t      debugEnabled: debugEnabled,\n\t      initialConnectEnabled: initialConnectEnabled,\n\t      connectionConfig: connectionConfig,\n\t      reconnectEnabled: reconnectEnabled,\n\t      sockjsReconnectInterval: sockjsReconnectInterval,\n\t      sockjsOptions: sockjsOptions\n\t    };\n\t    _this.disconnectTimeoutEnabled = true;\n\t    _this.applyDefaultHeaders();\n\t    if (initialConnectEnabled) {\n\t      // asap create connection\n\t      _this.connect();\n\t    }\n\t    return _this;\n\t  }\n\n\t  /**\n\t   * @ngdoc method\n\t   * @module knalli.angular-vertxbus\n\t   * @methodOf knalli.angular-vertxbus.vertxEventBus\n\t   * @name .#configureConnect\n\t   *\n\t   * @description\n\t   * Reconfigure the connection details.\n\t   *\n\t   * @param {string} urlServer see {@link knalli.angular-vertxbus.vertxEventBusProvider#methods_useUrlServer vertxEventBusProvider.useUrlServer()}\n\t   * @param {string} [urlPath=/eventbus] see {@link knalli.angular-vertxbus.vertxEventBusProvider#methods_useUrlPath vertxEventBusProvider.useUrlPath()}\n\t   */\n\n\n\t  _createClass(EventBusAdapter, [{\n\t    key: 'configureConnection',\n\t    value: function configureConnection(urlServer) {\n\t      var urlPath = arguments.length <= 1 || arguments[1] === undefined ? '/eventbus' : arguments[1];\n\n\t      this.options.connectionConfig = new _ConnectionConfigHolder2.default({ urlServer: urlServer, urlPath: urlPath });\n\t      return this;\n\t    }\n\t  }, {\n\t    key: 'connect',\n\t    value: function connect() {\n\t      var _this2 = this;\n\n\t      // connect promise\n\t      var deferred = this.$q.defer();\n\t      // currently valid url\n\t      var url = '' + this.options.connectionConfig.urlServer + this.options.connectionConfig.urlPath;\n\t      if (this.options.debugEnabled) {\n\t        this.$log.debug('[Vert.x EB Stub] Enabled: connecting \\'' + url + '\\'');\n\t      }\n\t      // Because we have rebuild an EventBus object (because it have to rebuild a SockJS object)\n\t      // we must wrap the object. Therefore, we have to mimic the behavior of onopen and onclose each time.\n\t      this.instance = new this.EventBus(url, this.options.sockjsOptions);\n\t      this.instance.onopen = function () {\n\t        if (_this2.options.debugEnabled) {\n\t          _this2.$log.debug('[Vert.x EB Stub] Connected');\n\t        }\n\t        if (angular.isFunction(_this2.onopen)) {\n\t          _this2.onopen();\n\t        }\n\t        deferred.resolve();\n\t      };\n\t      // instance onClose handler\n\t      this.instance.onclose = function () {\n\t        if (_this2.options.debugEnabled) {\n\t          _this2.$log.debug('[Vert.x EB Stub] Reconnect in ' + _this2.options.sockjsReconnectInterval + 'ms');\n\t        }\n\t        if (angular.isFunction(_this2.onclose)) {\n\t          _this2.onclose();\n\t        }\n\t        _this2.instance = undefined;\n\n\t        if (!_this2.disconnectTimeoutEnabled) {\n\t          // reconnect required asap\n\t          if (_this2.options.debugEnabled) {\n\t            _this2.$log.debug('[Vert.x EB Stub] Reconnect immediately');\n\t          }\n\t          _this2.disconnectTimeoutEnabled = true;\n\t          _this2.connect();\n\t        } else if (_this2.options.reconnectEnabled) {\n\t          // automatic reconnect after timeout\n\t          if (_this2.options.debugEnabled) {\n\t            _this2.$log.debug('[Vert.x EB Stub] Reconnect in ' + _this2.options.sockjsReconnectInterval + 'ms');\n\t          }\n\t          _this2.$timeout(function () {\n\t            return _this2.connect();\n\t          }, _this2.options.sockjsReconnectInterval);\n\t        }\n\t      };\n\t      // instance onError handler\n\t      this.instance.onerror = function (message) {\n\t        if (angular.isFunction(_this2.onerror)) {\n\t          _this2.onerror(message);\n\t        }\n\t      };\n\t      return deferred.promise;\n\t    }\n\n\t    /**\n\t     * @ngdoc method\n\t     * @module knalli.angular-vertxbus\n\t     * @methodOf knalli.angular-vertxbus.vertxEventBus\n\t     * @name .#reconnect\n\t     *\n\t     * @description\n\t     * Reconnects the underlying connection.\n\t     *\n\t     * Unless a connection is open, it will connect using a new one.\n\t     *\n\t     * If a connection is already open, it will close this one and opens a new one. If `immediately` is `true`, the\n\t     * default timeout for reconnect will be skipped.\n\t     *\n\t     * @param {boolean} [immediately=false] optionally enforce a reconnect asap instead of using the timeout\n\t     */\n\n\t  }, {\n\t    key: 'reconnect',\n\t    value: function reconnect() {\n\t      var immediately = arguments.length <= 0 || arguments[0] === undefined ? false : arguments[0];\n\n\t      if (this.instance && this.instance.state === this.EventBus.OPEN) {\n\t        if (immediately) {\n\t          this.disconnectTimeoutEnabled = false;\n\t        }\n\t        this.instance.close();\n\t      } else {\n\t        this.connect();\n\t      }\n\t    }\n\n\t    /**\n\t     * @ngdoc method\n\t     * @module knalli.angular-vertxbus\n\t     * @methodOf knalli.angular-vertxbus.vertxEventBus\n\t     * @name .#close\n\t     *\n\t     * @description\n\t     * Closes the underlying connection.\n\t     *\n\t     * Note: If automatic reconnection is active, a new connection will be established after the {@link knalli.angular-vertxbus.vertxEventBusProvider#methods_useReconnect reconnect timeout}.\n\t     *\n\t     * See also:\n\t     * - {@link EventBus#methods_close EventBus.close()}\n\t     */\n\n\t  }, {\n\t    key: 'close',\n\t    value: function close() {\n\t      if (this.instance) {\n\t        this.instance.close();\n\t      }\n\t    }\n\n\t    /**\n\t     * @ngdoc method\n\t     * @module knalli.angular-vertxbus\n\t     * @methodOf knalli.angular-vertxbus.vertxEventBus\n\t     * @name .#send\n\t     *\n\t     * @description\n\t     * Sends a message\n\t     *\n\t     * See also:\n\t     * - {@link global.EventBus#methods_send EventBus.send()}\n\t     *\n\t     * @param {string} address target address\n\t     * @param {object} message payload message\n\t     * @param {object} headers optional headers\n\t     * @param {function=} replyHandler optional callback\n\t     */\n\n\t  }, {\n\t    key: 'send',\n\t    value: function send(address, message, headers, replyHandler) {\n\t      if (this.instance) {\n\t        var mergedHeaders = this.getMergedHeaders(headers);\n\t        this.instance.send(address, message, mergedHeaders, replyHandler);\n\t      }\n\t    }\n\n\t    /**\n\t     * @ngdoc method\n\t     * @module knalli.angular-vertxbus\n\t     * @methodOf knalli.angular-vertxbus.vertxEventBus\n\t     * @name .#publish\n\t     *\n\t     * @description\n\t     * Publishes a message\n\t     *\n\t     * See also:\n\t     * - {@link global.EventBus#methods_publish EventBus.publish()}\n\t     *\n\t     * @param {string} address target address\n\t     * @param {object} message payload message\n\t     * @param {object=} headers optional headers\n\t     */\n\n\t  }, {\n\t    key: 'publish',\n\t    value: function publish(address, message, headers) {\n\t      if (this.instance) {\n\t        var mergedHeaders = this.getMergedHeaders(headers);\n\t        this.instance.publish(address, message, mergedHeaders);\n\t      }\n\t    }\n\n\t    /**\n\t     * @ngdoc method\n\t     * @module knalli.angular-vertxbus\n\t     * @methodOf knalli.angular-vertxbus.vertxEventBus\n\t     * @name .#registerHandler\n\t     *\n\t     * @description\n\t     * Registers a listener\n\t     *\n\t     * See also:\n\t     * - {@link global.EventBus#methods_registerHandler EventBus.registerHandler()}\n\t     *\n\t     * @param {string} address target address\n\t     * @param {object=} headers optional headers\n\t     * @param {function} handler callback handler\n\t     */\n\n\t  }, {\n\t    key: 'registerHandler',\n\t    value: function registerHandler(address, headers, handler) {\n\t      var _this3 = this;\n\n\t      if (this.instance) {\n\t        var _ret = function () {\n\t          if (angular.isFunction(headers) && !handler) {\n\t            handler = headers;\n\t            headers = undefined;\n\t          }\n\t          var mergedHeaders = _this3.getMergedHeaders(headers);\n\t          _this3.instance.registerHandler(address, mergedHeaders, handler);\n\t          // and return the deregister callback\n\t          var deconstructor = function deconstructor() {\n\t            _this3.unregisterHandler(address, mergedHeaders, handler);\n\t          };\n\t          deconstructor.displayName = _config.moduleName + '.wrapper.eventbus.registerHandler.deconstructor';\n\t          return {\n\t            v: deconstructor\n\t          };\n\t        }();\n\n\t        if ((typeof _ret === 'undefined' ? 'undefined' : _typeof(_ret)) === \"object\") return _ret.v;\n\t      }\n\t    }\n\n\t    /**\n\t     * @ngdoc method\n\t     * @module knalli.angular-vertxbus\n\t     * @methodOf knalli.angular-vertxbus.vertxEventBus\n\t     * @name .#unregisterHandler\n\t     *\n\t     * @description\n\t     * Removes a registered a listener\n\t     *\n\t     * See also:\n\t     * - {@link global.EventBus#methods_unregisterHandler EventBus.unregisterHandler()}\n\t     *\n\t     * @param {string} address target address\n\t     * @param {object=} headers optional headers\n\t     * @param {function} handler callback handler to be removed\n\t     */\n\n\t  }, {\n\t    key: 'unregisterHandler',\n\t    value: function unregisterHandler(address, headers, handler) {\n\t      if (this.instance && this.instance.state === this.EventBus.OPEN) {\n\t        if (angular.isFunction(headers) && !handler) {\n\t          handler = headers;\n\t          headers = undefined;\n\t        }\n\t        var mergedHeaders = this.getMergedHeaders(headers);\n\t        this.instance.unregisterHandler(address, mergedHeaders, handler);\n\t      }\n\t    }\n\n\t    /**\n\t     * @ngdoc method\n\t     * @module knalli.angular-vertxbus\n\t     * @methodOf knalli.angular-vertxbus.vertxEventBus\n\t     * @name .#readyState\n\t     *\n\t     * @description\n\t     * Returns the current connection state\n\t     *\n\t     * @returns {number} value of vertx-eventbus connection states\n\t     */\n\n\t  }, {\n\t    key: 'readyState',\n\t    value: function readyState() {\n\t      if (this.instance) {\n\t        return this.instance.state;\n\t      } else {\n\t        return this.EventBus.CLOSED;\n\t      }\n\t    }\n\t  }, {\n\t    key: 'getOptions',\n\n\n\t    // private\n\t    value: function getOptions() {\n\t      // clone options\n\t      return angular.extend({}, this.options);\n\t    }\n\t  }, {\n\t    key: 'state',\n\t    get: function get() {\n\t      return this.readyState();\n\t    }\n\t  }]);\n\n\t  return EventBusAdapter;\n\t}(_BaseAdapter3.default);\n\n\texports.default = EventBusAdapter;\n\n/***/ },\n/* 5 */\n/***/ function(module, exports) {\n\n\t\"use strict\";\n\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\n\tvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n\tvar BaseAdapter = function () {\n\t  function BaseAdapter($q) {\n\t    _classCallCheck(this, BaseAdapter);\n\n\t    this.$q = $q;\n\t  }\n\n\t  _createClass(BaseAdapter, [{\n\t    key: \"configureConnection\",\n\t    value: function configureConnection() {}\n\t  }, {\n\t    key: \"connect\",\n\t    value: function connect() {\n\t      return this.$q.reject();\n\t    }\n\t  }, {\n\t    key: \"reconnect\",\n\t    value: function reconnect() {}\n\t  }, {\n\t    key: \"close\",\n\t    value: function close() {}\n\t  }, {\n\t    key: \"send\",\n\t    value: function send() {}\n\t  }, {\n\t    key: \"publish\",\n\t    value: function publish() {}\n\t  }, {\n\t    key: \"registerHandler\",\n\t    value: function registerHandler() {}\n\t  }, {\n\t    key: \"unregisterHandler\",\n\t    value: function unregisterHandler() {}\n\t  }, {\n\t    key: \"readyState\",\n\t    value: function readyState() {}\n\t  }, {\n\t    key: \"getOptions\",\n\t    value: function getOptions() {\n\t      return {};\n\t    }\n\n\t    // empty: can be overriden by externals\n\n\t  }, {\n\t    key: \"onopen\",\n\t    value: function onopen() {}\n\n\t    // empty: can be overriden by externals\n\n\t  }, {\n\t    key: \"onclose\",\n\t    value: function onclose() {}\n\n\t    // private\n\n\t  }, {\n\t    key: \"getDefaultHeaders\",\n\t    value: function getDefaultHeaders() {\n\t      return this.defaultHeaders;\n\t    }\n\n\t    /**\n\t     * @ngdoc method\n\t     * @module knalli.angular-vertxbus\n\t     * @methodOf knalli.angular-vertxbus.vertxEventBus\n\t     * @name .#applyDefaultHeaders\n\t     *\n\t     * @description\n\t     * Stores the given default headers\n\t     *\n\t     * @param {object} headers additional standard headers\n\t     */\n\n\t  }, {\n\t    key: \"applyDefaultHeaders\",\n\t    value: function applyDefaultHeaders() {\n\t      var headers = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];\n\n\t      this.defaultHeaders = angular.extend({}, headers);\n\t    }\n\n\t    // private\n\n\t  }, {\n\t    key: \"getMergedHeaders\",\n\t    value: function getMergedHeaders() {\n\t      var headers = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];\n\n\t      return angular.extend({}, this.defaultHeaders, headers);\n\t    }\n\t  }]);\n\n\t  return BaseAdapter;\n\t}();\n\n\texports.default = BaseAdapter;\n\n/***/ },\n/* 6 */\n/***/ function(module, exports) {\n\n\t\"use strict\";\n\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\n\tvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n\tvar ConnectionConfigHolder = function () {\n\t  function ConnectionConfigHolder(_ref) {\n\t    var urlServer = _ref.urlServer;\n\t    var urlPath = _ref.urlPath;\n\n\t    _classCallCheck(this, ConnectionConfigHolder);\n\n\t    this._urlServer = urlServer;\n\t    this._urlPath = urlPath;\n\t  }\n\n\t  _createClass(ConnectionConfigHolder, [{\n\t    key: \"urlServer\",\n\t    get: function get() {\n\t      return this._urlServer;\n\t    }\n\t  }, {\n\t    key: \"urlPath\",\n\t    get: function get() {\n\t      return this._urlPath;\n\t    }\n\t  }]);\n\n\t  return ConnectionConfigHolder;\n\t}();\n\n\texports.default = ConnectionConfigHolder;\n\n/***/ },\n/* 7 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\n\tvar _BaseAdapter2 = __webpack_require__(5);\n\n\tvar _BaseAdapter3 = _interopRequireDefault(_BaseAdapter2);\n\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n\tfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\n\tfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\n\tvar NoopAdapter = function (_BaseAdapter) {\n\t  _inherits(NoopAdapter, _BaseAdapter);\n\n\t  function NoopAdapter(EventBus, $q) {\n\t    _classCallCheck(this, NoopAdapter);\n\n\t    // actual EventBus type\n\t    var _this = _possibleConstructorReturn(this, Object.getPrototypeOf(NoopAdapter).call(this, $q));\n\n\t    _this.EventBus = EventBus;\n\t    return _this;\n\t  }\n\n\t  return NoopAdapter;\n\t}(_BaseAdapter3.default);\n\n\texports.default = NoopAdapter;\n\n/***/ },\n/* 8 */\n/***/ function(module, exports) {\n\n\tmodule.exports = __WEBPACK_EXTERNAL_MODULE_8__;\n\n/***/ },\n/* 9 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\n\tvar _EventBusDelegate = __webpack_require__(10);\n\n\tvar _EventBusDelegate2 = _interopRequireDefault(_EventBusDelegate);\n\n\tvar _NoopDelegate = __webpack_require__(14);\n\n\tvar _NoopDelegate2 = _interopRequireDefault(_NoopDelegate);\n\n\tvar _Delegator = __webpack_require__(15);\n\n\tvar _Delegator2 = _interopRequireDefault(_Delegator);\n\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n\t/**\n\t * @ngdoc service\n\t * @module knalli.angular-vertxbus\n\t * @name knalli.angular-vertxbus.vertxEventBusServiceProvider\n\t * @description\n\t * This is the configuration provider for {@link knalli.angular-vertxbus.vertxEventBusService}.\n\t */\n\n\tvar DEFAULTS = {\n\t  enabled: true,\n\t  debugEnabled: false,\n\t  authRequired: false,\n\t  prefix: 'vertx-eventbus.',\n\t  sockjsStateInterval: 10000,\n\t  messageBuffer: 10000\n\t};\n\n\tvar VertxEventBusServiceProvider = function VertxEventBusServiceProvider() {\n\t  var _this = this;\n\n\t  // options (globally, application-wide)\n\t  var options = angular.extend({}, DEFAULTS);\n\n\t  /**\n\t   * @ngdoc method\n\t   * @module knalli.angular-vertxbus\n\t   * @methodOf knalli.angular-vertxbus.vertxEventBusServiceProvider\n\t   * @name .#enable\n\t   *\n\t   * @description\n\t   * Enables or disables the service. This setup is immutable.\n\t   *\n\t   * @param {boolean} [value=true] service is enabled on startup\n\t   * @returns {object} this\n\t   */\n\t  this.enable = function () {\n\t    var value = arguments.length <= 0 || arguments[0] === undefined ? DEFAULTS.enabled : arguments[0];\n\n\t    options.enabled = value === true;\n\t    return _this;\n\t  };\n\n\t  /**\n\t   * @ngdoc method\n\t   * @module knalli.angular-vertxbus\n\t   * @methodOf knalli.angular-vertxbus.vertxEventBusServiceProvider\n\t   * @name .#useDebug\n\t   *\n\t   * @description\n\t   * Enables a verbose mode in which certain events will be logged to `$log`.\n\t   *\n\t   * @param {boolean} [value=false] verbose mode (using `$log`)\n\t   * @returns {object} this\n\t   */\n\t  this.useDebug = function () {\n\t    var value = arguments.length <= 0 || arguments[0] === undefined ? DEFAULTS.debugEnabled : arguments[0];\n\n\t    options.debugEnabled = value === true;\n\t    return _this;\n\t  };\n\n\t  /**\n\t   * @ngdoc method\n\t   * @module knalli.angular-vertxbus\n\t   * @methodOf knalli.angular-vertxbus.vertxEventBusServiceProvider\n\t   * @name .#usePrefix\n\t   *\n\t   * @description\n\t   * Overrides the default prefix which will be used for emitted events.\n\t   *\n\t   * @param {string} [value='vertx-eventbus.'] prefix used in event names\n\t   * @returns {object} this\n\t   */\n\t  this.usePrefix = function () {\n\t    var value = arguments.length <= 0 || arguments[0] === undefined ? DEFAULTS.prefix : arguments[0];\n\n\t    options.prefix = value;\n\t    return _this;\n\t  };\n\n\t  /**\n\t   * @ngdoc method\n\t   * @methodOf knalli.angular-vertxbus.vertxEventBusServiceProvider\n\t   * @name .#useSockJsStateInterval\n\t   *\n\t   *\n\t   * @description\n\t   * Overrides the interval of checking the connection is still valid (required for reconnecting automatically).\n\t   *\n\t   * @param {boolean} [value=10000] interval of checking the underlying connection's state (in ms)\n\t   * @returns {object} this\n\t   */\n\t  this.useSockJsStateInterval = function () {\n\t    var value = arguments.length <= 0 || arguments[0] === undefined ? DEFAULTS.sockjsStateInterval : arguments[0];\n\n\t    options.sockjsStateInterval = value;\n\t    return _this;\n\t  };\n\n\t  /**\n\t   * @ngdoc method\n\t   * @methodOf knalli.angular-vertxbus.vertxEventBusServiceProvider\n\t   * @name .#useMessageBuffer\n\t   *\n\t   * @description\n\t   * Enables buffering of (sending) messages.\n\t   *\n\t   * The setting defines the total amount of buffered messages (`0` no buffering). A message will be buffered if\n\t   * connection is still in progress, the connection is stale or a login is required/pending.\n\t   *\n\t   * @param {boolean} [value=0] allowed total amount of messages in the buffer\n\t   * @returns {object} this\n\t   */\n\t  this.useMessageBuffer = function () {\n\t    var value = arguments.length <= 0 || arguments[0] === undefined ? DEFAULTS.messageBuffer : arguments[0];\n\n\t    options.messageBuffer = value;\n\t    return _this;\n\t  };\n\n\t  /**\n\t   * @ngdoc method\n\t   * @module knalli.angular-vertxbus\n\t   * @methodOf knalli.angular-vertxbus.vertxEventBusServiceProvider\n\t   * @name .#authHandler\n\t   *\n\t   * @description\n\t   * Function or service reference name for function checking the authorization state.\n\t   *\n\t   * The result of the function must be a boolean or promise. The handler can (but is not required) to create authorization on demand.\n\t   * If it is resolved, the authorization is valid.\n\t   * If it is rejected, the authorization is invalid.\n\t   *\n\t   * @param {string|function} value authorization handler (either a function or a service name)\n\t   * @returns {object} promise\n\t   */\n\t  this.authHandler = function (value) {\n\t    options.authHandler = value;\n\t    options.authRequired = !!value;\n\t    return _this;\n\t  };\n\n\t  /**\n\t   * @ngdoc service\n\t   * @module knalli.angular-vertxbus\n\t   * @name knalli.angular-vertxbus.vertxEventBusService\n\t   * @description\n\t   * A service utilizing an underlying Vert.x Event Bus\n\t   *\n\t   * The advanced features of this service are:\n\t   *  - broadcasting the connection changes (vertx-eventbus.system.connected, vertx-eventbus.system.disconnected) on $rootScope\n\t   *  - registering all handlers again when a reconnect had been required\n\t   *  - supporting a promise when using send()\n\t   *  - adding aliases on (registerHandler), un (unregisterHandler) and emit (publish)\n\t   *\n\t   * Basic usage:\n\t   * <pre>\n\t   * module.controller('MyController', function('vertxEventService') {\n\t  *   vertxEventService.on('my.address', function(message) {\n\t  *     console.log(\"JSON Message received: \", message)\n\t  *   });\n\t  *   vertxEventService.publish('my.other.address', {type: 'foo', data: 'bar'});\n\t  * });\n\t   * </pre>\n\t   *\n\t   * Note the additional {@link knalli.angular-vertxbus.vertxEventBusServiceProvider configuration} of the module itself.\n\t   *\n\t   * @requires knalli.angular-vertxbus.vertxEventBus\n\t   * @requires $rootScope\n\t   * @requires $q\n\t   * @requires $interval\n\t   * @requires $log\n\t   * @requires $injector\n\t   */\n\t  /* @ngInject */\n\t  this.$get = function ($rootScope, $q, $interval, vertxEventBus, $log, $injector) {\n\t    // Current options (merged defaults with application-wide settings)\n\t    var instanceOptions = angular.extend({}, vertxEventBus.getOptions(), options);\n\t    if (instanceOptions.enabled) {\n\t      return new _Delegator2.default(new _EventBusDelegate2.default($rootScope, $interval, $log, $q, $injector, vertxEventBus, instanceOptions), $log);\n\t    } else {\n\t      return new _Delegator2.default(new _NoopDelegate2.default());\n\t    }\n\t  };\n\t  this.$get.$inject = [\"$rootScope\", \"$q\", \"$interval\", \"vertxEventBus\", \"$log\", \"$injector\"];\n\t};\n\n\texports.default = VertxEventBusServiceProvider;\n\n/***/ },\n/* 10 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\n\tvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\n\tvar _config = __webpack_require__(2);\n\n\tvar _Queue = __webpack_require__(11);\n\n\tvar _Queue2 = _interopRequireDefault(_Queue);\n\n\tvar _SimpleMap = __webpack_require__(12);\n\n\tvar _SimpleMap2 = _interopRequireDefault(_SimpleMap);\n\n\tvar _BaseDelegate2 = __webpack_require__(13);\n\n\tvar _BaseDelegate3 = _interopRequireDefault(_BaseDelegate2);\n\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n\tfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\n\tfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\n\t/**\n\t * @ngdoc event\n\t * @module knalli.angular-vertxbus\n\t * @eventOf knalli.angular-vertxbus.vertxEventBusService\n\t * @eventType broadcast on $rootScope\n\t * @name disconnected\n\t *\n\t * @description\n\t * After a connection was being terminated.\n\t *\n\t * Event name is `prefix + 'system.disconnected'` (see {@link knalli.angular-vertxbus.vertxEventBusServiceProvider#methods_usePrefix prefix})\n\t */\n\n\t/**\n\t * @ngdoc event\n\t * @module knalli.angular-vertxbus\n\t * @eventOf knalli.angular-vertxbus.vertxEventBusService\n\t * @eventType broadcast on $rootScope\n\t * @name connected\n\t *\n\t * @description\n\t * After a connection was being established\n\t *\n\t * Event name is `prefix + 'system.connected'` (see {@link knalli.angular-vertxbus.vertxEventBusServiceProvider#methods_usePrefix prefix})\n\t */\n\n\t/**\n\t * @ngdoc event\n\t * @module knalli.angular-vertxbus\n\t * @eventOf knalli.angular-vertxbus.vertxEventBusService\n\t * @eventType broadcast on $rootScope\n\t * @name login-succeeded\n\t *\n\t * @description\n\t * After a login has been validated successfully\n\t *\n\t * Event name is `prefix + 'system.login.succeeded'` (see {@link knalli.angular-vertxbus.vertxEventBusServiceProvider#methods_usePrefix prefix})\n\t *\n\t * @param {object} data data\n\t * @param {boolean} data.status must be `'ok'`\n\t */\n\n\t/**\n\t * @ngdoc event\n\t * @module knalli.angular-vertxbus\n\t * @eventOf knalli.angular-vertxbus.vertxEventBusService\n\t * @eventType broadcast on $rootScope\n\t * @name login-failed\n\t *\n\t * @description\n\t * After a login has been destroyed or was invalidated\n\t *\n\t * Event name is `prefix + 'system.login.failed'` (see {@link knalli.angular-vertxbus.vertxEventBusServiceProvider#methods_usePrefix prefix})\n\t *\n\t * @param {object} data data\n\t * @param {boolean} data.status must be not`'ok'`\n\t */\n\n\tvar EventBusDelegate = function (_BaseDelegate) {\n\t  _inherits(EventBusDelegate, _BaseDelegate);\n\n\t  function EventBusDelegate($rootScope, $interval, $log, $q, $injector, eventBus, _ref) {\n\t    var enabled = _ref.enabled;\n\t    var debugEnabled = _ref.debugEnabled;\n\t    var prefix = _ref.prefix;\n\t    var sockjsStateInterval = _ref.sockjsStateInterval;\n\t    var messageBuffer = _ref.messageBuffer;\n\t    var authRequired = _ref.authRequired;\n\t    var authHandler = _ref.authHandler;\n\n\t    _classCallCheck(this, EventBusDelegate);\n\n\t    var _this = _possibleConstructorReturn(this, Object.getPrototypeOf(EventBusDelegate).call(this));\n\n\t    _this.$rootScope = $rootScope;\n\t    _this.$interval = $interval;\n\t    _this.$log = $log;\n\t    _this.$q = $q;\n\t    _this.eventBus = eventBus;\n\t    _this.options = {\n\t      enabled: enabled,\n\t      debugEnabled: debugEnabled,\n\t      prefix: prefix,\n\t      sockjsStateInterval: sockjsStateInterval,\n\t      messageBuffer: messageBuffer,\n\t      authRequired: authRequired\n\t    };\n\t    if (angular.isFunction(authHandler)) {\n\t      _this.authHandler = authHandler;\n\t    } else if (angular.isString(authHandler)) {\n\t      try {\n\t        _this.authHandler = $injector.get(authHandler);\n\t      } catch (e) {\n\t        if (_this.options.debugEnabled) {\n\t          _this.$log.debug('[Vert.x EB Service] Failed to resolve authHandler: %s', e.message);\n\t        }\n\t      }\n\t    }\n\t    _this.connectionState = _this.eventBus.EventBus.CLOSED;\n\t    _this.states = {\n\t      connected: false,\n\t      authorized: false\n\t    };\n\t    _this.observers = [];\n\t    // internal store of buffered messages\n\t    _this.messageQueue = new _Queue2.default(_this.options.messageBuffer);\n\t    // internal map of callbacks\n\t    _this.callbackMap = new _SimpleMap2.default();\n\t    // asap\n\t    _this.initialize();\n\t    return _this;\n\t  }\n\n\t  // internal\n\n\n\t  _createClass(EventBusDelegate, [{\n\t    key: 'initialize',\n\t    value: function initialize() {\n\t      var _this2 = this;\n\n\t      this.eventBus.onopen = function () {\n\t        return _this2.onEventbusOpen();\n\t      };\n\t      this.eventBus.onclose = function () {\n\t        return _this2.onEventbusClose();\n\t      };\n\n\t      // Update the current connection state periodically.\n\t      var connectionIntervalCheck = function connectionIntervalCheck() {\n\t        return _this2.getConnectionState(true);\n\t      };\n\t      connectionIntervalCheck.displayName = 'connectionIntervalCheck';\n\t      this.$interval(function () {\n\t        return connectionIntervalCheck();\n\t      }, this.options.sockjsStateInterval);\n\t    }\n\n\t    // internal\n\n\t  }, {\n\t    key: 'onEventbusOpen',\n\t    value: function onEventbusOpen() {\n\t      var connectionStateFlipped = false;\n\t      this.getConnectionState(true);\n\t      if (!this.states.connected) {\n\t        this.states.connected = true;\n\t        connectionStateFlipped = true;\n\t      }\n\t      // Ensure all events will be re-attached\n\t      this.afterEventbusConnected();\n\t      // Everything is online and registered again, let's notify everybody\n\t      if (connectionStateFlipped) {\n\t        this.$rootScope.$broadcast(this.options.prefix + 'system.connected');\n\t      }\n\t      this.$rootScope.$digest(); // explicitly\n\t      // consume message queue?\n\t      if (this.options.messageBuffer && this.messageQueue.size()) {\n\t        while (this.messageQueue.size()) {\n\t          var fn = this.messageQueue.first();\n\t          if (angular.isFunction(fn)) {\n\t            fn();\n\t          }\n\t        }\n\t        this.$rootScope.$digest();\n\t      }\n\t    }\n\n\t    // internal\n\n\t  }, {\n\t    key: 'onEventbusClose',\n\t    value: function onEventbusClose() {\n\t      this.getConnectionState(true);\n\t      if (this.states.connected) {\n\t        this.states.connected = false;\n\t        this.$rootScope.$broadcast(this.options.prefix + 'system.disconnected');\n\t      }\n\t    }\n\n\t    // internal\n\n\t  }, {\n\t    key: 'observe',\n\t    value: function observe(observer) {\n\t      this.observers.push(observer);\n\t    }\n\n\t    // internal\n\n\t  }, {\n\t    key: 'afterEventbusConnected',\n\t    value: function afterEventbusConnected() {\n\t      var _iteratorNormalCompletion = true;\n\t      var _didIteratorError = false;\n\t      var _iteratorError = undefined;\n\n\t      try {\n\t        for (var _iterator = this.observers[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n\t          var observer = _step.value;\n\n\t          if (angular.isFunction(observer.afterEventbusConnected)) {\n\t            observer.afterEventbusConnected();\n\t          }\n\t        }\n\t      } catch (err) {\n\t        _didIteratorError = true;\n\t        _iteratorError = err;\n\t      } finally {\n\t        try {\n\t          if (!_iteratorNormalCompletion && _iterator.return) {\n\t            _iterator.return();\n\t          }\n\t        } finally {\n\t          if (_didIteratorError) {\n\t            throw _iteratorError;\n\t          }\n\t        }\n\t      }\n\t    }\n\t  }, {\n\t    key: 'registerHandler',\n\t    value: function registerHandler(address, headers, callback) {\n\t      var _this3 = this;\n\n\t      if (angular.isFunction(headers) && !callback) {\n\t        callback = headers;\n\t        headers = undefined;\n\t      }\n\t      if (!angular.isFunction(callback)) {\n\t        return;\n\t      }\n\t      if (this.options.debugEnabled) {\n\t        this.$log.debug('[Vert.x EB Service] Register handler for ' + address);\n\t      }\n\t      var callbackWrapper = function callbackWrapper(err, _ref2, replyTo) {\n\t        var body = _ref2.body;\n\n\t        callback(body, replyTo);\n\t        _this3.$rootScope.$digest();\n\t      };\n\t      callbackWrapper.displayName = _config.moduleName + '.service.delegate.live.registerHandler.callbackWrapper';\n\t      this.callbackMap.put(callback, callbackWrapper);\n\t      return this.eventBus.registerHandler(address, headers, callbackWrapper);\n\t    }\n\t  }, {\n\t    key: 'unregisterHandler',\n\t    value: function unregisterHandler(address, headers, callback) {\n\t      if (angular.isFunction(headers) && !callback) {\n\t        callback = headers;\n\t        headers = undefined;\n\t      }\n\t      if (!angular.isFunction(callback)) {\n\t        return;\n\t      }\n\t      if (this.options.debugEnabled) {\n\t        this.$log.debug('[Vert.x EB Service] Unregister handler for ' + address);\n\t      }\n\t      this.eventBus.unregisterHandler(address, headers, this.callbackMap.get(callback));\n\t      this.callbackMap.remove(callback);\n\t    }\n\t  }, {\n\t    key: 'send',\n\t    value: function send(address, message, headers) {\n\t      var _this4 = this;\n\n\t      var timeout = arguments.length <= 3 || arguments[3] === undefined ? 10000 : arguments[3];\n\t      var expectReply = arguments.length <= 4 || arguments[4] === undefined ? true : arguments[4];\n\n\t      var deferred = this.$q.defer();\n\t      var next = function next() {\n\t        if (expectReply) {\n\t          (function () {\n\t            // Register timeout for promise rejecting\n\t            var timer = _this4.$interval(function () {\n\t              if (_this4.options.debugEnabled) {\n\t                _this4.$log.debug('[Vert.x EB Service] send(\\'' + address + '\\') timed out');\n\t              }\n\t              deferred.reject();\n\t            }, timeout, 1);\n\t            // Send message\n\t            _this4.eventBus.send(address, message, headers, function (err, reply) {\n\t              _this4.$interval.cancel(timer); // because it's resolved\n\t              if (err) {\n\t                deferred.reject(err);\n\t              } else {\n\t                deferred.resolve(reply);\n\t              }\n\t            });\n\t          })();\n\t        } else {\n\t          _this4.eventBus.send(address, message, headers);\n\t          deferred.resolve(); // we don't care\n\t        }\n\t      };\n\t      next.displayName = _config.moduleName + '.service.delegate.live.send.next';\n\t      this.ensureOpenAuthConnection(next).then(null, deferred.reject);\n\t      return deferred.promise;\n\t    }\n\t  }, {\n\t    key: 'publish',\n\t    value: function publish(address, message, headers) {\n\t      var _this5 = this;\n\n\t      return this.ensureOpenAuthConnection(function () {\n\t        return _this5.eventBus.publish(address, message, headers);\n\t      });\n\t    }\n\n\t    /**\n\t     * Ensures the callback will be performed with an open connection.\n\t     *\n\t     * Unless an open connection was found, the callback will be queued in the message buffer (if available).\n\t     *\n\t     * @param {function} fn callback\n\t     * @returns {object} promise (resolved on either performed or queued)\n\t     */\n\n\t  }, {\n\t    key: 'ensureOpenConnection',\n\t    value: function ensureOpenConnection(fn) {\n\t      var deferred = this.$q.defer();\n\t      if (this.isConnectionOpen()) {\n\t        fn();\n\t        deferred.resolve({\n\t          inQueue: false\n\t        });\n\t      } else if (this.options.messageBuffer) {\n\t        this.messageQueue.push(fn);\n\t        deferred.resolve({\n\t          inQueue: true\n\t        });\n\t      } else {\n\t        deferred.reject();\n\t      }\n\t      return deferred.promise;\n\t    }\n\n\t    /**\n\t     * Ensures the callback will be performed with a valid session.\n\t     *\n\t     * Unless `authRequired` is enabled, this will be simple forward.\n\t     *\n\t     * Unless a valid session exist (but required), the callback will be not invoked.\n\t     *\n\t     * @param {function} fn callback\n\t     * @returns {object} promise (resolved on either performed or queued)\n\t     */\n\n\t  }, {\n\t    key: 'ensureOpenAuthConnection',\n\t    value: function ensureOpenAuthConnection(fn) {\n\t      var _this6 = this;\n\n\t      if (!this.options.authRequired) {\n\t        // easy: no login required\n\t        return this.ensureOpenConnection(fn);\n\t      } else {\n\t        var fnWrapper = function fnWrapper() {\n\t          if (_this6.authHandler) {\n\t            var onValidAuth = function onValidAuth() {\n\t              _this6.states.authorized = true;\n\t              fn();\n\t            };\n\t            var onInvalidAuth = function onInvalidAuth() {\n\t              _this6.states.authorized = false;\n\t              if (_this6.options.debugEnabled) {\n\t                _this6.$log.debug('[Vert.x EB Service] Message was not sent due authHandler rejected');\n\t              }\n\t            };\n\t            var authResult = _this6.authHandler(_this6.eventBus);\n\t            if (!(authResult && angular.isFunction(authResult.then))) {\n\t              if (_this6.options.debugEnabled) {\n\t                _this6.$log.debug('[Vert.x EB Service] Message was not sent because authHandler is returning not a promise');\n\t              }\n\t              return false;\n\t            }\n\t            authResult.then(onValidAuth, onInvalidAuth);\n\t            return true;\n\t          } else {\n\t            // ignore this message\n\t            if (_this6.options.debugEnabled) {\n\t              _this6.$log.debug('[Vert.x EB Service] Message was not sent because no authHandler is defined');\n\t            }\n\t            return false;\n\t          }\n\t        };\n\t        fnWrapper.displayName = _config.moduleName + '.service.delegate.live.ensureOpenAuthConnection.fnWrapper';\n\t        return this.ensureOpenConnection(fnWrapper);\n\t      }\n\t    }\n\n\t    /**\n\t     * Returns the current connection state. The state is being cached internally.\n\t     *\n\t     * @param {boolean=} [immediate=false] if true, the connection state will be queried directly.\n\t     * @returns {number} state type of vertx.EventBus\n\t     */\n\n\t  }, {\n\t    key: 'getConnectionState',\n\t    value: function getConnectionState(immediate) {\n\t      if (this.options.enabled) {\n\t        if (immediate) {\n\t          this.connectionState = this.eventBus.state;\n\t        }\n\t      } else {\n\t        this.connectionState = this.eventBus.EventBus.CLOSED;\n\t      }\n\t      return this.connectionState;\n\t    }\n\n\t    /**\n\t     * Returns true if the current connection state ({@link knalli.angular-vertxbus.vertxEventBusService#methods_getConnectionState getConnectionState()}) is `OPEN`.\n\t     *\n\t     * @returns {boolean} connection open state\n\t     */\n\n\t  }, {\n\t    key: 'isConnectionOpen',\n\t    value: function isConnectionOpen() {\n\t      return this.getConnectionState() === this.eventBus.EventBus.OPEN;\n\t    }\n\n\t    /**\n\t     * Returns true if the session is valid\n\t     *\n\t     * @returns {boolean} state\n\t     */\n\n\t  }, {\n\t    key: 'isAuthorized',\n\t    value: function isAuthorized() {\n\t      return this.states.authorized;\n\t    }\n\n\t    // internal\n\n\t  }, {\n\t    key: 'isConnected',\n\t    value: function isConnected() {\n\t      return this.states.connected;\n\t    }\n\t  }, {\n\t    key: 'isEnabled',\n\t    value: function isEnabled() {\n\t      return this.options.enabled;\n\t    }\n\n\t    /**\n\t     * Returns the current amount of messages in the internal buffer.\n\t     *\n\t     * @returns {number} amount\n\t     */\n\n\t  }, {\n\t    key: 'getMessageQueueLength',\n\t    value: function getMessageQueueLength() {\n\t      return this.messageQueue.size();\n\t    }\n\t  }]);\n\n\t  return EventBusDelegate;\n\t}(_BaseDelegate3.default);\n\n\texports.default = EventBusDelegate;\n\n/***/ },\n/* 11 */\n/***/ function(module, exports) {\n\n\t\"use strict\";\n\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\n\tvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n\t/*\n\t Simple queue implementation\n\n\t FIFO: #push() + #first()\n\t LIFO: #push() + #last()\n\t */\n\tvar Queue = function () {\n\t  function Queue() {\n\t    var maxSize = arguments.length <= 0 || arguments[0] === undefined ? 10 : arguments[0];\n\n\t    _classCallCheck(this, Queue);\n\n\t    this.maxSize = maxSize;\n\t    this.items = [];\n\t  }\n\n\t  _createClass(Queue, [{\n\t    key: \"push\",\n\t    value: function push(item) {\n\t      this.items.push(item);\n\t      return this.recalibrateBufferSize();\n\t    }\n\t  }, {\n\t    key: \"recalibrateBufferSize\",\n\t    value: function recalibrateBufferSize() {\n\t      while (this.items.length > this.maxSize) {\n\t        this.first();\n\t      }\n\t      return this;\n\t    }\n\t  }, {\n\t    key: \"last\",\n\t    value: function last() {\n\t      return this.items.pop();\n\t    }\n\t  }, {\n\t    key: \"first\",\n\t    value: function first() {\n\t      return this.items.shift(0);\n\t    }\n\t  }, {\n\t    key: \"size\",\n\t    value: function size() {\n\t      return this.items.length;\n\t    }\n\t  }]);\n\n\t  return Queue;\n\t}();\n\n\texports.default = Queue;\n\n/***/ },\n/* 12 */\n/***/ function(module, exports) {\n\n\t\"use strict\";\n\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\n\tvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n\t/*\n\t Simple Map implementation\n\n\t This implementation allows usage of non serializable keys for values.\n\t */\n\tvar SimpleMap = function () {\n\t  function SimpleMap() {\n\t    _classCallCheck(this, SimpleMap);\n\n\t    this.clear();\n\t  }\n\n\t  // Stores the value under the key.\n\t  // Chainable\n\n\n\t  _createClass(SimpleMap, [{\n\t    key: \"put\",\n\t    value: function put(key, value) {\n\t      var idx = this._indexForKey(key);\n\t      if (idx > -1) {\n\t        this.values[idx] = value;\n\t      } else {\n\t        this.keys.push(key);\n\t        this.values.push(value);\n\t      }\n\t      return this;\n\t    }\n\n\t    // Returns value for key, otherwise undefined.\n\n\t  }, {\n\t    key: \"get\",\n\t    value: function get(key) {\n\t      var idx = this._indexForKey(key);\n\t      if (idx > -1) {\n\t        return this.values[idx];\n\t      }\n\t    }\n\n\t    // Returns true if the key exists.\n\n\t  }, {\n\t    key: \"containsKey\",\n\t    value: function containsKey(key) {\n\t      var idx = this._indexForKey(key);\n\t      return idx > -1;\n\t    }\n\n\t    // Returns true if the value exists.\n\n\t  }, {\n\t    key: \"containsValue\",\n\t    value: function containsValue(value) {\n\t      var idx = this._indexForValue(value);\n\t      return idx > -1;\n\t    }\n\n\t    // Removes the key and its value.\n\n\t  }, {\n\t    key: \"remove\",\n\t    value: function remove(key) {\n\t      var idx = this._indexForKey(key);\n\t      if (idx > -1) {\n\t        this.keys[idx] = undefined;\n\t        this.values[idx] = undefined;\n\t      }\n\t    }\n\n\t    // Clears all keys and values.\n\n\t  }, {\n\t    key: \"clear\",\n\t    value: function clear() {\n\t      this.keys = [];\n\t      this.values = [];\n\t      return this;\n\t    }\n\n\t    // Returns index of key, otherwise -1.\n\n\t  }, {\n\t    key: \"_indexForKey\",\n\t    value: function _indexForKey(key) {\n\t      for (var i in this.keys) {\n\t        if (key === this.keys[i]) {\n\t          return i;\n\t        }\n\t      }\n\t      return -1;\n\t    }\n\t  }, {\n\t    key: \"_indexForValue\",\n\t    value: function _indexForValue(value) {\n\t      for (var i in this.values) {\n\t        if (value === this.values[i]) {\n\t          return i;\n\t        }\n\t      }\n\t      return -1;\n\t    }\n\t  }]);\n\n\t  return SimpleMap;\n\t}();\n\n\texports.default = SimpleMap;\n\n/***/ },\n/* 13 */\n/***/ function(module, exports) {\n\n\t\"use strict\";\n\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\n\tvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n\tvar BaseDelegate = function () {\n\t  function BaseDelegate() {\n\t    _classCallCheck(this, BaseDelegate);\n\t  }\n\n\t  _createClass(BaseDelegate, [{\n\t    key: \"observe\",\n\t    value: function observe() {}\n\t  }, {\n\t    key: \"getConnectionState\",\n\t    value: function getConnectionState() {\n\t      return 3; // CLOSED\n\t    }\n\t  }, {\n\t    key: \"isConnectionOpen\",\n\t    value: function isConnectionOpen() {\n\t      return false;\n\t    }\n\t  }, {\n\t    key: \"isAuthorized\",\n\t    value: function isAuthorized() {\n\t      return false;\n\t    }\n\t  }, {\n\t    key: \"isEnabled\",\n\t    value: function isEnabled() {\n\t      return false;\n\t    }\n\t  }, {\n\t    key: \"isConnected\",\n\t    value: function isConnected() {\n\t      return false;\n\t    }\n\t  }, {\n\t    key: \"send\",\n\t    value: function send() {}\n\t  }, {\n\t    key: \"publish\",\n\t    value: function publish() {}\n\t  }]);\n\n\t  return BaseDelegate;\n\t}();\n\n\texports.default = BaseDelegate;\n\n/***/ },\n/* 14 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\n\tvar _BaseDelegate2 = __webpack_require__(13);\n\n\tvar _BaseDelegate3 = _interopRequireDefault(_BaseDelegate2);\n\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n\tfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\n\tfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\n\tvar NoopDelegate = function (_BaseDelegate) {\n\t  _inherits(NoopDelegate, _BaseDelegate);\n\n\t  function NoopDelegate() {\n\t    _classCallCheck(this, NoopDelegate);\n\n\t    return _possibleConstructorReturn(this, Object.getPrototypeOf(NoopDelegate).apply(this, arguments));\n\t  }\n\n\t  return NoopDelegate;\n\t}(_BaseDelegate3.default);\n\n\texports.default = NoopDelegate;\n\n/***/ },\n/* 15 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\n\tvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\n\tvar _config = __webpack_require__(2);\n\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n\tvar Delegator = function () {\n\t  function Delegator(delegate, $log) {\n\t    var _this = this;\n\n\t    _classCallCheck(this, Delegator);\n\n\t    this.delegate = delegate;\n\t    this.$log = $log;\n\t    this.handlers = {};\n\t    this.delegate.observe({\n\t      afterEventbusConnected: function afterEventbusConnected() {\n\t        return _this.afterEventbusConnected();\n\t      }\n\t    });\n\t  }\n\n\t  _createClass(Delegator, [{\n\t    key: 'afterEventbusConnected',\n\t    value: function afterEventbusConnected() {\n\t      for (var address in this.handlers) {\n\t        if (Object.prototype.hasOwnProperty.call(this.handlers, address)) {\n\t          var callbacks = this.handlers[address];\n\t          if (callbacks && callbacks.length) {\n\t            var _iteratorNormalCompletion = true;\n\t            var _didIteratorError = false;\n\t            var _iteratorError = undefined;\n\n\t            try {\n\t              for (var _iterator = callbacks[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n\t                var _step$value = _step.value;\n\t                var headers = _step$value.headers;\n\t                var callback = _step$value.callback;\n\n\t                this.delegate.registerHandler(address, headers, callback);\n\t              }\n\t            } catch (err) {\n\t              _didIteratorError = true;\n\t              _iteratorError = err;\n\t            } finally {\n\t              try {\n\t                if (!_iteratorNormalCompletion && _iterator.return) {\n\t                  _iterator.return();\n\t                }\n\t              } finally {\n\t                if (_didIteratorError) {\n\t                  throw _iteratorError;\n\t                }\n\t              }\n\t            }\n\t          }\n\t        }\n\t      }\n\t    }\n\n\t    /**\n\t     * @ngdoc method\n\t     * @module knalli.angular-vertxbus\n\t     * @methodOf knalli.angular-vertxbus.vertxEventBusService\n\t     * @name .#registerHandler\n\t     *\n\t     * @description\n\t     * Registers a callback handler for the specified address match.\n\t     *\n\t     * @param {string} address target address\n\t     * @param {object} headers optional headers\n\t     * @param {function} callback handler with params `(message, replyTo)`\n\t     * @returns {function} deconstructor\n\t     */\n\n\t  }, {\n\t    key: 'registerHandler',\n\t    value: function registerHandler(address, headers, callback) {\n\t      var _this2 = this;\n\n\t      if (!this.handlers[address]) {\n\t        this.handlers[address] = [];\n\t      }\n\t      var handler = { headers: headers, callback: callback };\n\t      this.handlers[address].push(handler);\n\t      var unregisterFn = null;\n\t      if (this.delegate.isConnectionOpen()) {\n\t        this.delegate.registerHandler(address, headers, callback);\n\t        unregisterFn = function unregisterFn() {\n\t          return _this2.delegate.unregisterHandler(address, headers, callback);\n\t        };\n\t      }\n\t      // and return the deregister callback\n\t      var deconstructor = function deconstructor() {\n\t        if (unregisterFn) {\n\t          unregisterFn();\n\t          unregisterFn = undefined;\n\t        }\n\t        // Remove from internal map\n\t        if (_this2.handlers[address]) {\n\t          var index = _this2.handlers[address].indexOf(handler);\n\t          if (index > -1) {\n\t            _this2.handlers[address].splice(index, 1);\n\t          }\n\t          if (_this2.handlers[address].length < 1) {\n\t            _this2.handlers[address] = undefined;\n\t          }\n\t        }\n\t      };\n\t      deconstructor.displayName = _config.moduleName + '.service.registerHandler.deconstructor';\n\t      return deconstructor;\n\t    }\n\n\t    /**\n\t     * @ngdoc method\n\t     * @module knalli.angular-vertxbus\n\t     * @methodOf knalli.angular-vertxbus.vertxEventBusService\n\t     * @name .#on\n\t     *\n\t     * @description\n\t     * See (using {@link knalli.angular-vertxbus.vertxEventBusService#methods_registerHandler registerHandler()})\n\t     */\n\n\t  }, {\n\t    key: 'on',\n\t    value: function on(address, headers, callback) {\n\t      return this.registerHandler(address, headers, callback);\n\t    }\n\n\t    /**\n\t     * @ngdoc method\n\t     * @module knalli.angular-vertxbus\n\t     * @methodOf knalli.angular-vertxbus.vertxEventBusService\n\t     * @name .#addListener\n\t     *\n\t     * @description\n\t     * See (using {@link knalli.angular-vertxbus.vertxEventBusService#methods_registerHandler registerHandler()})\n\t     */\n\n\t  }, {\n\t    key: 'addListener',\n\t    value: function addListener(address, headers, callback) {\n\t      return this.registerHandler(address, headers, callback);\n\t    }\n\n\t    /**\n\t     * @ngdoc method\n\t     * @module knalli.angular-vertxbus\n\t     * @methodOf knalli.angular-vertxbus.vertxEventBusService\n\t     * @name .#unregisterHandler\n\t     *\n\t     * @description\n\t     * Removes a callback handler for the specified address match.\n\t     *\n\t     * @param {string} address target address\n\t     * @param {object} headers optional headers\n\t     * @param {function} callback handler with params `(message, replyTo)`\n\t     */\n\n\t  }, {\n\t    key: 'unregisterHandler',\n\t    value: function unregisterHandler(address, headers, callback) {\n\t      // Remove from internal map\n\t      if (this.handlers[address]) {\n\t        var index = this.handlers[address].indexOf({ headers: headers, callback: callback });\n\t        if (index > -1) {\n\t          this.handlers[address].splice(index, 1);\n\t        }\n\t        if (this.handlers[address].length < 1) {\n\t          this.handlers[address] = undefined;\n\t        }\n\t      }\n\t      // Remove from real instance\n\t      if (this.delegate.isConnectionOpen()) {\n\t        this.delegate.unregisterHandler(address, headers, callback);\n\t      }\n\t    }\n\n\t    /**\n\t     * @ngdoc method\n\t     * @module knalli.angular-vertxbus\n\t     * @methodOf knalli.angular-vertxbus.vertxEventBusService\n\t     * @name .#un\n\t     *\n\t     * @description\n\t     * See (using {@link knalli.angular-vertxbus.vertxEventBusService#methods_registerHandler unregisterHandler()})\n\t     */\n\n\t  }, {\n\t    key: 'un',\n\t    value: function un(address, headers, callback) {\n\t      return this.unregisterHandler(address, headers, callback);\n\t    }\n\n\t    /**\n\t     * @ngdoc method\n\t     * @module knalli.angular-vertxbus\n\t     * @methodOf knalli.angular-vertxbus.vertxEventBusService\n\t     * @name .#removeListener\n\t     *\n\t     * @description\n\t     * See (using {@link knalli.angular-vertxbus.vertxEventBusService#methods_registerHandler unregisterHandler()})\n\t     */\n\n\t  }, {\n\t    key: 'removeListener',\n\t    value: function removeListener(address, headers, callback) {\n\t      return this.unregisterHandler(address, headers, callback);\n\t    }\n\n\t    /**\n\t     * @ngdoc method\n\t     * @module knalli.angular-vertxbus\n\t     * @methodOf knalli.angular-vertxbus.vertxEventBusService\n\t     * @name .#send\n\t     *\n\t     * @description\n\t     * Sends a message to the specified address (using {@link knalli.angular-vertxbus.vertxEventBus#methods_send vertxEventBus.send()}).\n\t     *\n\t     * @param {string} address target address\n\t     * @param {object} message payload message\n\t     * @param {object} headers headers\n\t     * @param {number=} [options.timeout=10000] (in ms) after which the promise will be rejected\n\t     * @param {boolean=} [options.expectReply=true] if false, the promise will be resolved directly and\n\t     *                                       no replyHandler will be created\n\t     * @returns {object} promise\n\t     */\n\n\t  }, {\n\t    key: 'send',\n\t    value: function send(address, message) {\n\t      var headers = arguments.length <= 2 || arguments[2] === undefined ? {} : arguments[2];\n\t      var options = arguments.length <= 3 || arguments[3] === undefined ? { timeout: 10000, expectReply: true } : arguments[3];\n\n\t      return this.delegate.send(address, message, headers, options.timeout, options.expectReply);\n\t    }\n\n\t    /**\n\t     * @ngdoc method\n\t     * @module knalli.angular-vertxbus\n\t     * @methodOf knalli.angular-vertxbus.vertxEventBusService\n\t     * @name .#publish\n\t     *\n\t     * @description\n\t     * Publishes a message to the specified address (using {@link knalli.angular-vertxbus.vertxEventBus#methods_publish vertxEventBus.publish()}).\n\t     *\n\t     * @param {string} address target address\n\t     * @param {object} message payload message\n\t     * @param {object=} headers headers\n\t     * @returns {object} promise (resolved on either performed or queued)\n\t     */\n\n\t  }, {\n\t    key: 'publish',\n\t    value: function publish(address, message) {\n\t      var headers = arguments.length <= 2 || arguments[2] === undefined ? {} : arguments[2];\n\n\t      return this.delegate.publish(address, message, headers);\n\t    }\n\n\t    /**\n\t     * @ngdoc method\n\t     * @module knalli.angular-vertxbus\n\t     * @methodOf knalli.angular-vertxbus.vertxEventBusService\n\t     * @name .#emit\n\t     *\n\t     * @description\n\t     * See (using {@link knalli.angular-vertxbus.vertxEventBusService#methods_publish publish()})\n\t     */\n\n\t  }, {\n\t    key: 'emit',\n\t    value: function emit(address, message) {\n\t      var headers = arguments.length <= 2 || arguments[2] === undefined ? {} : arguments[2];\n\n\t      return this.publish(address, message, headers);\n\t    }\n\n\t    /**\n\t     * @ngdoc method\n\t     * @module knalli.angular-vertxbus\n\t     * @methodOf knalli.angular-vertxbus.vertxEventBusService\n\t     * @name .#getConnectionState\n\t     *\n\t     * @description\n\t     * Returns the current connection state. The state is being cached internally.\n\t     *\n\t     * @returns {number} state type of vertx.EventBus\n\t     */\n\n\t  }, {\n\t    key: 'getConnectionState',\n\t    value: function getConnectionState() {\n\t      return this.delegate.getConnectionState();\n\t    }\n\n\t    /**\n\t     * @ngdoc method\n\t     * @module knalli.angular-vertxbus\n\t     * @methodOf knalli.angular-vertxbus.vertxEventBusService\n\t     * @name .#readyState\n\t     *\n\t     * @description\n\t     * See (using {@link knalli.angular-vertxbus.vertxEventBusService#methods_getConnectionState getConnectionState()})\n\t     */\n\n\t  }, {\n\t    key: 'readyState',\n\t    value: function readyState() {\n\t      return this.getConnectionState();\n\t    }\n\n\t    /**\n\t     * @ngdoc method\n\t     * @module knalli.angular-vertxbus\n\t     * @methodOf knalli.angular-vertxbus.vertxEventBusService\n\t     * @name .#isConnectionOpen\n\t     *\n\t     * @description\n\t     * Returns true if the current connection state ({@link knalli.angular-vertxbus.vertxEventBusService#methods_getConnectionState getConnectionState()}) is `OPEN`.\n\t     *\n\t     * @returns {boolean} connection open state\n\t     */\n\n\t  }, {\n\t    key: 'isConnectionOpen',\n\t    value: function isConnectionOpen() {\n\t      return this.isConnectionOpen();\n\t    }\n\n\t    /**\n\t     * @ngdoc method\n\t     * @module knalli.angular-vertxbus\n\t     * @methodOf knalli.angular-vertxbus.vertxEventBusService\n\t     * @name .#isEnabled\n\t     *\n\t     * @description\n\t     * Returns true if service is being enabled.\n\t     *\n\t     * @returns {boolean} state\n\t     */\n\n\t  }, {\n\t    key: 'isEnabled',\n\t    value: function isEnabled() {\n\t      return this.delegate.isEnabled();\n\t    }\n\n\t    /**\n\t     * @ngdoc method\n\t     * @module knalli.angular-vertxbus\n\t     * @methodOf knalli.angular-vertxbus.vertxEventBusService\n\t     * @name .#isConnected\n\t     *\n\t     * @description\n\t     * Returns true if service (and the eventbus) is being connected.\n\t     *\n\t     * @returns {boolean} state\n\t     */\n\n\t  }, {\n\t    key: 'isConnected',\n\t    value: function isConnected() {\n\t      return this.delegate.isConnected();\n\t    }\n\n\t    /**\n\t     * @ngdoc method\n\t     * @module knalli.angular-vertxbus\n\t     * @methodOf knalli.angular-vertxbus.vertxEventBusService\n\t     * @name .#isAuthorized\n\t     *\n\t     * @description\n\t     * Returns true if the authorization is valid\n\t     *\n\t     * @returns {boolean} state\n\t     */\n\n\t  }, {\n\t    key: 'isAuthorized',\n\t    value: function isAuthorized() {\n\t      return this.delegate.isAuthorized();\n\t    }\n\n\t    /**\n\t     * @ngdoc method\n\t     * @module knalli.angular-vertxbus\n\t     * @methodOf knalli.angular-vertxbus.vertxEventBusService\n\t     * @name .#isValidSession\n\t     *\n\t     * See (using {@link knalli.angular-vertxbus.vertxEventBusService#methods_isAuthorized isAuthorized()})\n\t     */\n\n\t  }, {\n\t    key: 'isValidSession',\n\t    value: function isValidSession() {\n\t      return this.delegate.isAuthorized();\n\t    }\n\n\t    /**\n\t     * @ngdoc method\n\t     * @module knalli.angular-vertxbus\n\t     * @methodOf knalli.angular-vertxbus.vertxEventBusService\n\t     * @name .#getMessageQueueLength\n\t     *\n\t     * @description\n\t     * Returns the current amount of messages in the internal buffer.\n\t     *\n\t     * @returns {number} amount\n\t     */\n\n\t  }, {\n\t    key: 'getMessageQueueLength',\n\t    value: function getMessageQueueLength() {\n\t      return this.delegate.getMessageQueueLength();\n\t    }\n\t  }]);\n\n\t  return Delegator;\n\t}();\n\n\texports.default = Delegator;\n\n/***/ }\n/******/ ])\n});\n;\n\n\n/** WEBPACK FOOTER **\n ** dist/angular-vertxbus.min.js\n **/"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n/** WEBPACK FOOTER **\n ** webpack/bootstrap 767704362563894bafc3\n **/","import moduleName from './module';\n\nexport default moduleName;\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/index.js\n **/","import {moduleName} from './config';\n\nimport VertxEventBusWrapperProvider from './lib/VertxEventBusWrapperProvider';\nimport VertxEventBusServiceProvider from './lib/VertxEventBusServiceProvider';\n\n/**\n * @ngdoc overview\n * @module knalli.angular-vertxbus\n * @name knalli.angular-vertxbus\n * @description\n *\n * Client side library using VertX Event Bus as an Angular Service module\n *\n * You have to define the module dependency, this module is named `knalli.angular-vertxbus`.\n *\n * <pre>\n *   angular.module('app', ['knalli.angular-vertxbus'])\n *     .controller('MyCtrl', function(vertxEventBus, vertxEventBusService) {\n *\n *       // using the EventBus directly\n *       vertxEventBus.send('my.address', {data: 123}, function (reply) {\n *         // your reply comes here\n *       });\n *\n *       // using the service\n *       vertxEventBusService.send('my.address', {data: 123}, {timeout: 500})\n *         .then(function (reply) {\n *           // your reply comes here\n *         })\n *         .catch(function (err) {\n *           // something went wrong, no connection, no login, timed out, or so\n *         });\n *     });\n * </pre>\n *\n * The module itself provides following components:\n * - {@link knalli.angular-vertxbus.vertxEventBus vertxEventBus}: a low level wrapper around `vertx.EventBus`\n * - {@link knalli.angular-vertxbus.vertxEventBusService vertxEventBusService}: a high level service around the wrapper\n *\n * While the wrapper only provides one single instance (even on reconnects), the service supports automatically\n * reconnect management, authorization and a clean promise based api.\n *\n * If you are looking for a low integration of `vertxbus.EventBus` as an AngularJS component, the wrapper will be your\n * choice. The only difference (and requirement for the wrapper actually) is how it will manage and replace the\n * underlying instance of the current `vertx.EventBus`.\n *\n * However, if you are looking for a simple, clean and promised based high api, the service is much better you.\n */\nexport default angular\n\n  .module(moduleName, ['ng'])\n\n  .provider('vertxEventBus', VertxEventBusWrapperProvider)\n  .provider('vertxEventBusService', VertxEventBusServiceProvider)\n\n  .name;\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/module.js\n **/","const moduleName = 'knalli.angular-vertxbus';\n\nexport {moduleName};\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/config.js\n **/","import EventBusAdapter from './adapter/EventBusAdapter';\nimport NoopAdapter from './adapter/NoopAdapter';\nimport ConnectionConfigHolder from './support/ConnectionConfigHolder';\n\nimport EventBus from 'vertx-eventbus';\n\n/**\n * @ngdoc service\n * @module knalli.angular-vertxbus\n * @name knalli.angular-vertxbus.vertxEventBusProvider\n * @description\n * An AngularJS wrapper for projects using the VertX Event Bus\n */\n\nconst DEFAULTS = {\n  enabled : true,\n  debugEnabled : false,\n  initialConnectEnabled : true,\n  urlServer : `${location.protocol}//${location.hostname}` + ((() => {\n    if (location.port) {\n      return `:${location.port}`;\n    }\n  })() || ''),\n  urlPath : '/eventbus',\n  reconnectEnabled : true,\n  sockjsReconnectInterval : 10000,\n  sockjsOptions : {}\n};\n\nlet VertxEventBusWrapperProvider = function () {\n\n  // options (globally, application-wide)\n  var options = angular.extend({}, DEFAULTS);\n\n  /**\n   * @ngdoc method\n   * @module knalli.angular-vertxbus\n   * @methodOf knalli.angular-vertxbus.vertxEventBusProvider\n   * @name .#enable\n   *\n   * @description\n   * Enables or disables the service. This setup is immutable.\n   *\n   * @param {boolean} [value=true] service is enabled on startup\n   * @returns {object} this\n   */\n  this.enable = (value = DEFAULTS.enabled) => {\n    options.enabled = (value === true);\n    return this;\n  };\n\n  /**\n   * @ngdoc method\n   * @module knalli.angular-vertxbus\n   * @methodOf knalli.angular-vertxbus.vertxEventBusProvider\n   * @name .#disableAutoConnect\n   *\n   * @description\n   * Disables the auto connection feature.\n   *\n   * This feature will be only available if `enable == true`.\n   *\n   * @param {boolean} [value=true] auto connect on startup\n   * @returns {object} this\n   */\n  this.disableAutoConnect = () => {\n    options.initialConnectEnabled = false;\n    return this;\n  };\n\n  /**\n   * @ngdoc method\n   * @module knalli.angular-vertxbus\n   * @methodOf knalli.angular-vertxbus.vertxEventBusProvider\n   * @name .#useDebug\n   *\n   * @description\n   * Enables a verbose mode in which certain events will be logged to `$log`.\n   *\n   * @param {boolean} [value=false] verbose mode (using `$log`)\n   * @returns {object} this\n   */\n  this.useDebug = (value = DEFAULTS.debugEnabled) => {\n    options.debugEnabled = (value === true);\n    return this;\n  };\n\n  /**\n   * @ngdoc method\n   * @module knalli.angular-vertxbus\n   * @methodOf knalli.angular-vertxbus.vertxEventBusProvider\n   * @name .#useUrlServer\n   *\n   * @description\n   * Overrides the url part \"server\" for connecting. The default is based on\n   * - `location.protocol`\n   * - `location.hostname`\n   * - `location.port`\n   *\n   * i.e. `http://domain.tld` or `http://domain.tld:port`\n   *\n   * @param {boolean} [value=$computed] server to connect (default based on `location.protocol`, `location.hostname` and `location.port`)\n   * @returns {object} this\n   */\n  this.useUrlServer = (value = DEFAULTS.urlServer) => {\n    options.urlServer = value;\n    return this;\n  };\n\n  /**\n   * @ngdoc method\n   * @module knalli.angular-vertxbus\n   * @methodOf knalli.angular-vertxbus.vertxEventBusProvider\n   * @name .#useUrlPath\n   *\n   * @description\n   * Overrides the url part \"path\" for connection.\n   *\n   * @param {boolean} [value='/eventbus'] path to connect\n   * @returns {object} this\n   */\n  this.useUrlPath = (value = DEFAULTS.urlPath) => {\n    options.urlPath = value;\n    return this;\n  };\n\n  /**\n   * @ngdoc method\n   * @module knalli.angular-vertxbus\n   * @methodOf knalli.angular-vertxbus.vertxEventBusProvider\n   * @name .#useReconnect\n   *\n   * @description\n   * Enables or disables the automatic reconnect handling.\n   *\n   * @param {boolean} [value=true] if a disconnect was being noted, a reconnect will be enforced automatically\n   * @returns {object} this\n   */\n  this.useReconnect = (value = DEFAULTS.reconnectEnabled) => {\n    options.reconnectEnabled = value;\n    return this;\n  };\n\n  /**\n   * @ngdoc method\n   * @module knalli.angular-vertxbus\n   * @methodOf knalli.angular-vertxbus.vertxEventBusProvider\n   * @name .#useSockJsReconnectInterval\n   *\n   * @description\n   * Overrides the timeout for reconnecting after a disconnect was found.\n   *\n   * @param {boolean} [value=10000] time between a disconnect and the next try to reconnect (in ms)\n   * @returns {object} this\n   */\n  this.useSockJsReconnectInterval = (value = DEFAULTS.sockjsReconnectInterval) => {\n    options.sockjsReconnectInterval = value;\n    return this;\n  };\n\n  /**\n   * @ngdoc method\n   * @module knalli.angular-vertxbus\n   * @methodOf knalli.angular-vertxbus.vertxEventBusProvider\n   * @name .#useSockJsOptions\n   *\n   * @description\n   * Sets additional params for the `SockJS` instance.\n   *\n   * Internally, it will be applied (as `options`) like `new SockJS(url, undefined, options)`.\n   *\n   * @param {boolean} [value={}]  optional params for raw SockJS options\n   * @returns {object} this\n   */\n  this.useSockJsOptions = (value = DEFAULTS.sockjsOptions) => {\n    options.sockjsOptions = value;\n    return this;\n  };\n\n  /**\n   * @ngdoc service\n   * @module knalli.angular-vertxbus\n   * @name knalli.angular-vertxbus.vertxEventBus\n   * @description\n   * A stub representing the Vert.x EventBus (core functionality)\n   *\n   * Because the Event Bus cannot handle a reconnect (because of the underlaying SockJS), a\n   * new instance of the bus have to be created.\n   * This stub ensures only one object holding the current active instance of the bus.\n   *\n   * The stub supports theses Vert.x Event Bus APIs:\n   *  - {@link knalli.angular-vertxbus.vertxEventBus#methods_close close()}\n   *  - {@link knalli.angular-vertxbus.vertxEventBus#methods_send send(address, message, handler)}\n   *  - {@link knalli.angular-vertxbus.vertxEventBus#methods_publish publish(address, message)}\n   *  - {@link knalli.angular-vertxbus.vertxEventBus#methods_registerHandler registerHandler(adress, handler)}\n   *  - {@link knalli.angular-vertxbus.vertxEventBus#methods_unregisterHandler unregisterHandler(address, handler)}\n   *  - {@link knalli.angular-vertxbus.vertxEventBus#methods_readyState readyState()}\n   *\n   * Furthermore, the stub supports theses extra APIs:\n   *  - {@link knalli.angular-vertxbus.vertxEventBus#methods_reconnect reconnect()}\n   *\n   * @requires $timeout\n   * @requires $log\n   */\n  /* @ngInject */\n  this.$get = ($timeout, $log, $q) => {\n    // Current options (merged defaults with application-wide settings)\n    let instanceOptions = angular.extend({}, DEFAULTS, options);\n    if (instanceOptions.enabled && EventBus) {\n      if (instanceOptions.debugEnabled) {\n        $log.debug('[Vert.x EB Stub] Enabled');\n      }\n\n      // aggregate server connection params\n      instanceOptions.connectionConfig = new ConnectionConfigHolder({\n        urlServer : instanceOptions.urlServer,\n        urlPath : instanceOptions.urlPath\n      });\n      delete instanceOptions.urlServer;\n      delete instanceOptions.urlPath;\n\n      return new EventBusAdapter(EventBus, $timeout, $log, $q, instanceOptions);\n    } else {\n      if (instanceOptions.debugEnabled) {\n        $log.debug('[Vert.x EB Stub] Disabled');\n      }\n      return new NoopAdapter(EventBus, $q);\n    }\n  };\n\n};\n\nexport default VertxEventBusWrapperProvider;\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/lib/VertxEventBusWrapperProvider.js\n **/","import {moduleName} from '../../config.js';\n\nimport BaseAdapter from './BaseAdapter';\nimport ConnectionConfigHolder from './../support/ConnectionConfigHolder';\n\n/**\n * @ngdoc service\n * @module global\n * @name global.EventBus\n *\n * @description\n * This is the interface of `EventBus`. It is not included.\n */\n\n/**\n * @ngdoc method\n * @module global\n * @methodOf global.EventBus\n * @name .#close\n */\n\n/**\n * @ngdoc method\n * @module global\n * @methodOf global.EventBus\n * @name .#send\n *\n * @param {string} address target address\n * @param {object} message payload message\n * @param {object=} headers headers\n * @param {function=} replyHandler optional callback\n * @param {function=} failureHandler optional callback\n */\n\n/**\n * @ngdoc method\n * @module global\n * @methodOf global.EventBus\n * @name .#publish\n *\n * @param {string} address target address\n * @param {object} message payload message\n * @param {object=} headers headers\n */\n\n/**\n * @ngdoc method\n * @module global\n * @methodOf global.EventBus\n * @name .#registerHandler\n *\n * @param {string} address target address\n * @param {function} handler callback handler\n * @param {object=} headers headers\n */\n\n/**\n * @ngdoc method\n * @module global\n * @methodOf global.EventBus\n * @name .#unregisterHandler\n *\n * @param {string} address target address\n * @param {function} handler callback handler to be removed\n * @param {object=} headers headers\n */\n\n/**\n * @ngdoc property\n * @module global\n * @propertyOf global.EventBus\n * @name .#onopen\n * @description\n * Defines the callback called on opening the connection.\n */\n\n/**\n * @ngdoc property\n * @module global\n * @propertyOf global.EventBus\n * @name .#onclose\n * @description\n * Defines the callback called on closing the connection.\n */\n\n/**\n * @ngdoc property\n * @module global\n * @propertyOf global.EventBus\n * @name .#onerror\n * @description\n * Defines the callback called on any error.\n */\n\nexport default class EventBusAdapter extends BaseAdapter {\n\n  constructor(EventBus, $timeout, $log, $q, {\n    enabled,\n    debugEnabled,\n    initialConnectEnabled,\n    connectionConfig,\n    reconnectEnabled,\n    sockjsReconnectInterval,\n    sockjsOptions\n    }) {\n    super($q);\n    // actual EventBus type\n    this.EventBus = EventBus;\n    this.$timeout = $timeout;\n    this.$log = $log;\n    this.$q = $q;\n    this.options = {\n      enabled,\n      debugEnabled,\n      initialConnectEnabled,\n      connectionConfig,\n      reconnectEnabled,\n      sockjsReconnectInterval,\n      sockjsOptions\n    };\n    this.disconnectTimeoutEnabled = true;\n    this.applyDefaultHeaders();\n    if (initialConnectEnabled) {\n      // asap create connection\n      this.connect();\n    }\n  }\n\n  /**\n   * @ngdoc method\n   * @module knalli.angular-vertxbus\n   * @methodOf knalli.angular-vertxbus.vertxEventBus\n   * @name .#configureConnect\n   *\n   * @description\n   * Reconfigure the connection details.\n   *\n   * @param {string} urlServer see {@link knalli.angular-vertxbus.vertxEventBusProvider#methods_useUrlServer vertxEventBusProvider.useUrlServer()}\n   * @param {string} [urlPath=/eventbus] see {@link knalli.angular-vertxbus.vertxEventBusProvider#methods_useUrlPath vertxEventBusProvider.useUrlPath()}\n   */\n  configureConnection(urlServer, urlPath = '/eventbus') {\n    this.options.connectionConfig = new ConnectionConfigHolder({urlServer, urlPath});\n    return this;\n  }\n\n  connect() {\n    // connect promise\n    let deferred = this.$q.defer();\n    // currently valid url\n    let url = `${this.options.connectionConfig.urlServer}${this.options.connectionConfig.urlPath}`;\n    if (this.options.debugEnabled) {\n      this.$log.debug(`[Vert.x EB Stub] Enabled: connecting '${url}'`);\n    }\n    // Because we have rebuild an EventBus object (because it have to rebuild a SockJS object)\n    // we must wrap the object. Therefore, we have to mimic the behavior of onopen and onclose each time.\n    this.instance = new this.EventBus(url, this.options.sockjsOptions);\n    this.instance.onopen = () => {\n      if (this.options.debugEnabled) {\n        this.$log.debug('[Vert.x EB Stub] Connected');\n      }\n      if (angular.isFunction(this.onopen)) {\n        this.onopen();\n      }\n      deferred.resolve();\n    };\n    // instance onClose handler\n    this.instance.onclose = () => {\n      if (this.options.debugEnabled) {\n        this.$log.debug(`[Vert.x EB Stub] Reconnect in ${this.options.sockjsReconnectInterval}ms`);\n      }\n      if (angular.isFunction(this.onclose)) {\n        this.onclose();\n      }\n      this.instance = undefined;\n\n      if (!this.disconnectTimeoutEnabled) {\n        // reconnect required asap\n        if (this.options.debugEnabled) {\n          this.$log.debug('[Vert.x EB Stub] Reconnect immediately');\n        }\n        this.disconnectTimeoutEnabled = true;\n        this.connect();\n      } else if (this.options.reconnectEnabled) {\n        // automatic reconnect after timeout\n        if (this.options.debugEnabled) {\n          this.$log.debug(`[Vert.x EB Stub] Reconnect in ${this.options.sockjsReconnectInterval}ms`);\n        }\n        this.$timeout((() => this.connect()), this.options.sockjsReconnectInterval);\n      }\n    };\n    // instance onError handler\n    this.instance.onerror = (message) => {\n      if (angular.isFunction(this.onerror)) {\n        this.onerror(message);\n      }\n    };\n    return deferred.promise;\n  }\n\n  /**\n   * @ngdoc method\n   * @module knalli.angular-vertxbus\n   * @methodOf knalli.angular-vertxbus.vertxEventBus\n   * @name .#reconnect\n   *\n   * @description\n   * Reconnects the underlying connection.\n   *\n   * Unless a connection is open, it will connect using a new one.\n   *\n   * If a connection is already open, it will close this one and opens a new one. If `immediately` is `true`, the\n   * default timeout for reconnect will be skipped.\n   *\n   * @param {boolean} [immediately=false] optionally enforce a reconnect asap instead of using the timeout\n   */\n  reconnect(immediately = false) {\n    if (this.instance && this.instance.state === this.EventBus.OPEN) {\n      if (immediately) {\n        this.disconnectTimeoutEnabled = false;\n      }\n      this.instance.close();\n    } else {\n      this.connect();\n    }\n  }\n\n  /**\n   * @ngdoc method\n   * @module knalli.angular-vertxbus\n   * @methodOf knalli.angular-vertxbus.vertxEventBus\n   * @name .#close\n   *\n   * @description\n   * Closes the underlying connection.\n   *\n   * Note: If automatic reconnection is active, a new connection will be established after the {@link knalli.angular-vertxbus.vertxEventBusProvider#methods_useReconnect reconnect timeout}.\n   *\n   * See also:\n   * - {@link EventBus#methods_close EventBus.close()}\n   */\n  close() {\n    if (this.instance) {\n      this.instance.close();\n    }\n  }\n\n  /**\n   * @ngdoc method\n   * @module knalli.angular-vertxbus\n   * @methodOf knalli.angular-vertxbus.vertxEventBus\n   * @name .#send\n   *\n   * @description\n   * Sends a message\n   *\n   * See also:\n   * - {@link global.EventBus#methods_send EventBus.send()}\n   *\n   * @param {string} address target address\n   * @param {object} message payload message\n   * @param {object} headers optional headers\n   * @param {function=} replyHandler optional callback\n   */\n  send(address, message, headers, replyHandler) {\n    if (this.instance) {\n      const mergedHeaders = this.getMergedHeaders(headers);\n      this.instance.send(address, message, mergedHeaders, replyHandler);\n    }\n  }\n\n  /**\n   * @ngdoc method\n   * @module knalli.angular-vertxbus\n   * @methodOf knalli.angular-vertxbus.vertxEventBus\n   * @name .#publish\n   *\n   * @description\n   * Publishes a message\n   *\n   * See also:\n   * - {@link global.EventBus#methods_publish EventBus.publish()}\n   *\n   * @param {string} address target address\n   * @param {object} message payload message\n   * @param {object=} headers optional headers\n   */\n  publish(address, message, headers) {\n    if (this.instance) {\n      const mergedHeaders = this.getMergedHeaders(headers);\n      this.instance.publish(address, message, mergedHeaders);\n    }\n  }\n\n  /**\n   * @ngdoc method\n   * @module knalli.angular-vertxbus\n   * @methodOf knalli.angular-vertxbus.vertxEventBus\n   * @name .#registerHandler\n   *\n   * @description\n   * Registers a listener\n   *\n   * See also:\n   * - {@link global.EventBus#methods_registerHandler EventBus.registerHandler()}\n   *\n   * @param {string} address target address\n   * @param {object=} headers optional headers\n   * @param {function} handler callback handler\n   */\n  registerHandler(address, headers, handler) {\n    if (this.instance) {\n      if (angular.isFunction(headers) && !handler) {\n        handler = headers;\n        headers = undefined;\n      }\n      const mergedHeaders = this.getMergedHeaders(headers);\n      this.instance.registerHandler(address, mergedHeaders, handler);\n      // and return the deregister callback\n      let deconstructor = () => {\n        this.unregisterHandler(address, mergedHeaders, handler);\n      };\n      deconstructor.displayName = `${moduleName}.wrapper.eventbus.registerHandler.deconstructor`;\n      return deconstructor;\n    }\n  }\n\n  /**\n   * @ngdoc method\n   * @module knalli.angular-vertxbus\n   * @methodOf knalli.angular-vertxbus.vertxEventBus\n   * @name .#unregisterHandler\n   *\n   * @description\n   * Removes a registered a listener\n   *\n   * See also:\n   * - {@link global.EventBus#methods_unregisterHandler EventBus.unregisterHandler()}\n   *\n   * @param {string} address target address\n   * @param {object=} headers optional headers\n   * @param {function} handler callback handler to be removed\n   */\n  unregisterHandler(address, headers, handler) {\n    if (this.instance && this.instance.state === this.EventBus.OPEN) {\n      if (angular.isFunction(headers) && !handler) {\n        handler = headers;\n        headers = undefined;\n      }\n      const mergedHeaders = this.getMergedHeaders(headers);\n      this.instance.unregisterHandler(address, mergedHeaders, handler);\n    }\n  }\n\n  /**\n   * @ngdoc method\n   * @module knalli.angular-vertxbus\n   * @methodOf knalli.angular-vertxbus.vertxEventBus\n   * @name .#readyState\n   *\n   * @description\n   * Returns the current connection state\n   *\n   * @returns {number} value of vertx-eventbus connection states\n   */\n  readyState() {\n    if (this.instance) {\n      return this.instance.state;\n    } else {\n      return this.EventBus.CLOSED;\n    }\n  }\n\n  get state() {\n    return this.readyState();\n  }\n\n  // private\n  getOptions() {\n    // clone options\n    return angular.extend({}, this.options);\n  }\n\n}\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/lib/adapter/EventBusAdapter.js\n **/","export default class BaseAdapter {\n\n  constructor($q) {\n    this.$q = $q;\n  }\n\n  configureConnection() {\n  }\n\n  connect() {\n    return this.$q.reject();\n  }\n\n  reconnect() {\n  }\n\n  close() {\n  }\n\n  send() {\n  }\n\n  publish() {\n  }\n\n  registerHandler() {\n  }\n\n  unregisterHandler() {\n  }\n\n  readyState() {\n  }\n\n  getOptions() {\n    return {};\n  }\n\n  // empty: can be overriden by externals\n  onopen() {\n  }\n\n  // empty: can be overriden by externals\n  onclose() {\n  }\n\n  // private\n  getDefaultHeaders() {\n    return this.defaultHeaders;\n  }\n\n  /**\n   * @ngdoc method\n   * @module knalli.angular-vertxbus\n   * @methodOf knalli.angular-vertxbus.vertxEventBus\n   * @name .#applyDefaultHeaders\n   *\n   * @description\n   * Stores the given default headers\n   *\n   * @param {object} headers additional standard headers\n   */\n  applyDefaultHeaders(headers = {}) {\n    this.defaultHeaders = angular.extend({}, headers);\n  }\n\n  // private\n  getMergedHeaders(headers = {}) {\n    return angular.extend({}, this.defaultHeaders, headers);\n  }\n\n}\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/lib/adapter/BaseAdapter.js\n **/","export default class ConnectionConfigHolder {\n\n  constructor({urlServer, urlPath}) {\n    this._urlServer = urlServer;\n    this._urlPath = urlPath;\n  }\n\n  get urlServer() {\n    return this._urlServer;\n  }\n\n  get urlPath() {\n    return this._urlPath;\n  }\n\n}\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/lib/support/ConnectionConfigHolder.js\n **/","import BaseAdapter from './BaseAdapter';\n\nexport default class NoopAdapter extends BaseAdapter {\n\n  constructor(EventBus, $q) {\n    super($q);\n    // actual EventBus type\n    this.EventBus = EventBus;\n  }\n\n}\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/lib/adapter/NoopAdapter.js\n **/","import EventBusDelegate from './service/delegate/EventBusDelegate';\nimport NoopDelegate from './service/delegate/NoopDelegate';\nimport Delegator from './service/Delegator';\n\n/**\n * @ngdoc service\n * @module knalli.angular-vertxbus\n * @name knalli.angular-vertxbus.vertxEventBusServiceProvider\n * @description\n * This is the configuration provider for {@link knalli.angular-vertxbus.vertxEventBusService}.\n */\n\nconst DEFAULTS = {\n  enabled : true,\n  debugEnabled : false,\n  authRequired : false,\n  prefix : 'vertx-eventbus.',\n  sockjsStateInterval : 10000,\n  messageBuffer : 10000\n};\n\nlet VertxEventBusServiceProvider = function () {\n\n  // options (globally, application-wide)\n  var options = angular.extend({}, DEFAULTS);\n\n  /**\n   * @ngdoc method\n   * @module knalli.angular-vertxbus\n   * @methodOf knalli.angular-vertxbus.vertxEventBusServiceProvider\n   * @name .#enable\n   *\n   * @description\n   * Enables or disables the service. This setup is immutable.\n   *\n   * @param {boolean} [value=true] service is enabled on startup\n   * @returns {object} this\n   */\n  this.enable = (value = DEFAULTS.enabled) => {\n    options.enabled = (value === true);\n    return this;\n  };\n\n  /**\n   * @ngdoc method\n   * @module knalli.angular-vertxbus\n   * @methodOf knalli.angular-vertxbus.vertxEventBusServiceProvider\n   * @name .#useDebug\n   *\n   * @description\n   * Enables a verbose mode in which certain events will be logged to `$log`.\n   *\n   * @param {boolean} [value=false] verbose mode (using `$log`)\n   * @returns {object} this\n   */\n  this.useDebug = (value = DEFAULTS.debugEnabled) => {\n    options.debugEnabled = (value === true);\n    return this;\n  };\n\n  /**\n   * @ngdoc method\n   * @module knalli.angular-vertxbus\n   * @methodOf knalli.angular-vertxbus.vertxEventBusServiceProvider\n   * @name .#usePrefix\n   *\n   * @description\n   * Overrides the default prefix which will be used for emitted events.\n   *\n   * @param {string} [value='vertx-eventbus.'] prefix used in event names\n   * @returns {object} this\n   */\n  this.usePrefix = (value = DEFAULTS.prefix) => {\n    options.prefix = value;\n    return this;\n  };\n\n  /**\n   * @ngdoc method\n   * @methodOf knalli.angular-vertxbus.vertxEventBusServiceProvider\n   * @name .#useSockJsStateInterval\n   *\n   *\n   * @description\n   * Overrides the interval of checking the connection is still valid (required for reconnecting automatically).\n   *\n   * @param {boolean} [value=10000] interval of checking the underlying connection's state (in ms)\n   * @returns {object} this\n   */\n  this.useSockJsStateInterval = (value = DEFAULTS.sockjsStateInterval) => {\n    options.sockjsStateInterval = value;\n    return this;\n  };\n\n  /**\n   * @ngdoc method\n   * @methodOf knalli.angular-vertxbus.vertxEventBusServiceProvider\n   * @name .#useMessageBuffer\n   *\n   * @description\n   * Enables buffering of (sending) messages.\n   *\n   * The setting defines the total amount of buffered messages (`0` no buffering). A message will be buffered if\n   * connection is still in progress, the connection is stale or a login is required/pending.\n   *\n   * @param {boolean} [value=0] allowed total amount of messages in the buffer\n   * @returns {object} this\n   */\n  this.useMessageBuffer = (value = DEFAULTS.messageBuffer) => {\n    options.messageBuffer = value;\n    return this;\n  };\n\n  /**\n   * @ngdoc method\n   * @module knalli.angular-vertxbus\n   * @methodOf knalli.angular-vertxbus.vertxEventBusServiceProvider\n   * @name .#authHandler\n   *\n   * @description\n   * Function or service reference name for function checking the authorization state.\n   *\n   * The result of the function must be a boolean or promise. The handler can (but is not required) to create authorization on demand.\n   * If it is resolved, the authorization is valid.\n   * If it is rejected, the authorization is invalid.\n   *\n   * @param {string|function} value authorization handler (either a function or a service name)\n   * @returns {object} promise\n   */\n  this.authHandler = (value) => {\n    options.authHandler = value;\n    options.authRequired = !!value;\n    return this;\n  };\n\n  /**\n   * @ngdoc service\n   * @module knalli.angular-vertxbus\n   * @name knalli.angular-vertxbus.vertxEventBusService\n   * @description\n   * A service utilizing an underlying Vert.x Event Bus\n   *\n   * The advanced features of this service are:\n   *  - broadcasting the connection changes (vertx-eventbus.system.connected, vertx-eventbus.system.disconnected) on $rootScope\n   *  - registering all handlers again when a reconnect had been required\n   *  - supporting a promise when using send()\n   *  - adding aliases on (registerHandler), un (unregisterHandler) and emit (publish)\n   *\n   * Basic usage:\n   * <pre>\n   * module.controller('MyController', function('vertxEventService') {\n *   vertxEventService.on('my.address', function(message) {\n *     console.log(\"JSON Message received: \", message)\n *   });\n *   vertxEventService.publish('my.other.address', {type: 'foo', data: 'bar'});\n * });\n   * </pre>\n   *\n   * Note the additional {@link knalli.angular-vertxbus.vertxEventBusServiceProvider configuration} of the module itself.\n   *\n   * @requires knalli.angular-vertxbus.vertxEventBus\n   * @requires $rootScope\n   * @requires $q\n   * @requires $interval\n   * @requires $log\n   * @requires $injector\n   */\n  /* @ngInject */\n  this.$get = ($rootScope, $q, $interval, vertxEventBus, $log, $injector) => {\n    // Current options (merged defaults with application-wide settings)\n    let instanceOptions = angular.extend({}, vertxEventBus.getOptions(), options);\n    if (instanceOptions.enabled) {\n      return new Delegator(\n        new EventBusDelegate($rootScope, $interval, $log, $q, $injector, vertxEventBus, instanceOptions),\n        $log\n      );\n    } else {\n      return new Delegator(new NoopDelegate());\n    }\n  };\n\n};\n\nexport default VertxEventBusServiceProvider;\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/lib/VertxEventBusServiceProvider.js\n **/","import {moduleName} from '../../../config';\n\nimport Queue from './../../support/Queue';\nimport SimpleMap from './../../support/SimpleMap';\nimport BaseDelegate from './BaseDelegate';\n\n/**\n * @ngdoc event\n * @module knalli.angular-vertxbus\n * @eventOf knalli.angular-vertxbus.vertxEventBusService\n * @eventType broadcast on $rootScope\n * @name disconnected\n *\n * @description\n * After a connection was being terminated.\n *\n * Event name is `prefix + 'system.disconnected'` (see {@link knalli.angular-vertxbus.vertxEventBusServiceProvider#methods_usePrefix prefix})\n */\n\n/**\n * @ngdoc event\n * @module knalli.angular-vertxbus\n * @eventOf knalli.angular-vertxbus.vertxEventBusService\n * @eventType broadcast on $rootScope\n * @name connected\n *\n * @description\n * After a connection was being established\n *\n * Event name is `prefix + 'system.connected'` (see {@link knalli.angular-vertxbus.vertxEventBusServiceProvider#methods_usePrefix prefix})\n */\n\n/**\n * @ngdoc event\n * @module knalli.angular-vertxbus\n * @eventOf knalli.angular-vertxbus.vertxEventBusService\n * @eventType broadcast on $rootScope\n * @name login-succeeded\n *\n * @description\n * After a login has been validated successfully\n *\n * Event name is `prefix + 'system.login.succeeded'` (see {@link knalli.angular-vertxbus.vertxEventBusServiceProvider#methods_usePrefix prefix})\n *\n * @param {object} data data\n * @param {boolean} data.status must be `'ok'`\n */\n\n/**\n * @ngdoc event\n * @module knalli.angular-vertxbus\n * @eventOf knalli.angular-vertxbus.vertxEventBusService\n * @eventType broadcast on $rootScope\n * @name login-failed\n *\n * @description\n * After a login has been destroyed or was invalidated\n *\n * Event name is `prefix + 'system.login.failed'` (see {@link knalli.angular-vertxbus.vertxEventBusServiceProvider#methods_usePrefix prefix})\n *\n * @param {object} data data\n * @param {boolean} data.status must be not`'ok'`\n */\n\nexport default class EventBusDelegate extends BaseDelegate {\n\n  constructor($rootScope, $interval, $log, $q, $injector, eventBus, {\n    enabled,\n    debugEnabled,\n    prefix,\n    sockjsStateInterval,\n    messageBuffer,\n    authRequired,\n    authHandler\n    }) {\n    super();\n    this.$rootScope = $rootScope;\n    this.$interval = $interval;\n    this.$log = $log;\n    this.$q = $q;\n    this.eventBus = eventBus;\n    this.options = {\n      enabled,\n      debugEnabled,\n      prefix,\n      sockjsStateInterval,\n      messageBuffer,\n      authRequired\n    };\n    if (angular.isFunction(authHandler)) {\n      this.authHandler = authHandler;\n    } else if (angular.isString(authHandler)) {\n      try {\n        this.authHandler = $injector.get(authHandler);\n      } catch (e) {\n        if (this.options.debugEnabled) {\n          this.$log.debug('[Vert.x EB Service] Failed to resolve authHandler: %s', e.message);\n        }\n      }\n    }\n    this.connectionState = this.eventBus.EventBus.CLOSED;\n    this.states = {\n      connected: false,\n      authorized: false\n    };\n    this.observers = [];\n    // internal store of buffered messages\n    this.messageQueue = new Queue(this.options.messageBuffer);\n    // internal map of callbacks\n    this.callbackMap = new SimpleMap();\n    // asap\n    this.initialize();\n  }\n\n  // internal\n  initialize() {\n    this.eventBus.onopen = () => this.onEventbusOpen();\n    this.eventBus.onclose = () => this.onEventbusClose();\n\n    // Update the current connection state periodically.\n    let connectionIntervalCheck = () => this.getConnectionState(true);\n    connectionIntervalCheck.displayName = 'connectionIntervalCheck';\n    this.$interval((() => connectionIntervalCheck()), this.options.sockjsStateInterval);\n  }\n\n  // internal\n  onEventbusOpen() {\n    let connectionStateFlipped = false;\n    this.getConnectionState(true);\n    if (!this.states.connected) {\n      this.states.connected = true;\n      connectionStateFlipped = true;\n    }\n    // Ensure all events will be re-attached\n    this.afterEventbusConnected();\n    // Everything is online and registered again, let's notify everybody\n    if (connectionStateFlipped) {\n      this.$rootScope.$broadcast(`${this.options.prefix}system.connected`);\n    }\n    this.$rootScope.$digest(); // explicitly\n    // consume message queue?\n    if (this.options.messageBuffer && this.messageQueue.size()) {\n      while (this.messageQueue.size()) {\n        let fn = this.messageQueue.first();\n        if (angular.isFunction(fn)) {\n          fn();\n        }\n      }\n      this.$rootScope.$digest();\n    }\n  }\n\n  // internal\n  onEventbusClose() {\n    this.getConnectionState(true);\n    if (this.states.connected) {\n      this.states.connected = false;\n      this.$rootScope.$broadcast(`${this.options.prefix}system.disconnected`);\n    }\n  }\n\n  // internal\n  observe(observer) {\n    this.observers.push(observer);\n  }\n\n  // internal\n  afterEventbusConnected() {\n    for (let observer of this.observers) {\n      if (angular.isFunction(observer.afterEventbusConnected)) {\n        observer.afterEventbusConnected();\n      }\n    }\n  }\n\n  registerHandler(address, headers, callback) {\n    if (angular.isFunction(headers) && !callback) {\n      callback = headers;\n      headers = undefined;\n    }\n    if (!angular.isFunction(callback)) {\n      return;\n    }\n    if (this.options.debugEnabled) {\n      this.$log.debug(`[Vert.x EB Service] Register handler for ${address}`);\n    }\n    var callbackWrapper = (err, {body}, replyTo) => {\n      callback(body, replyTo);\n      this.$rootScope.$digest();\n    };\n    callbackWrapper.displayName = `${moduleName}.service.delegate.live.registerHandler.callbackWrapper`;\n    this.callbackMap.put(callback, callbackWrapper);\n    return this.eventBus.registerHandler(address, headers, callbackWrapper);\n  }\n\n  unregisterHandler(address, headers, callback) {\n    if (angular.isFunction(headers) && !callback) {\n      callback = headers;\n      headers = undefined;\n    }\n    if (!angular.isFunction(callback)) {\n      return;\n    }\n    if (this.options.debugEnabled) {\n      this.$log.debug(`[Vert.x EB Service] Unregister handler for ${address}`);\n    }\n    this.eventBus.unregisterHandler(address, headers, this.callbackMap.get(callback));\n    this.callbackMap.remove(callback);\n  }\n\n  send(address, message, headers, timeout = 10000, expectReply = true) {\n    let deferred = this.$q.defer();\n    let next = () => {\n      if (expectReply) {\n        // Register timeout for promise rejecting\n        let timer = this.$interval((() => {\n          if (this.options.debugEnabled) {\n            this.$log.debug(`[Vert.x EB Service] send('${address}') timed out`);\n          }\n          deferred.reject();\n        }), timeout, 1);\n        // Send message\n        this.eventBus.send(address, message, headers, (err, reply) => {\n          this.$interval.cancel(timer); // because it's resolved\n          if (err) {\n            deferred.reject(err);\n          } else {\n            deferred.resolve(reply);\n          }\n        });\n      } else {\n        this.eventBus.send(address, message, headers);\n        deferred.resolve(); // we don't care\n      }\n    };\n    next.displayName = `${moduleName}.service.delegate.live.send.next`;\n    this.ensureOpenAuthConnection(next).then(null, deferred.reject);\n    return deferred.promise;\n  }\n\n  publish(address, message, headers) {\n    return this.ensureOpenAuthConnection(() => this.eventBus.publish(address, message, headers));\n  }\n\n  /**\n   * Ensures the callback will be performed with an open connection.\n   *\n   * Unless an open connection was found, the callback will be queued in the message buffer (if available).\n   *\n   * @param {function} fn callback\n   * @returns {object} promise (resolved on either performed or queued)\n   */\n  ensureOpenConnection(fn) {\n    const deferred = this.$q.defer();\n    if (this.isConnectionOpen()) {\n      fn();\n      deferred.resolve({\n        inQueue: false\n      });\n    } else if (this.options.messageBuffer) {\n      this.messageQueue.push(fn);\n      deferred.resolve({\n        inQueue: true\n      });\n    } else {\n      deferred.reject();\n    }\n    return deferred.promise;\n  }\n\n  /**\n   * Ensures the callback will be performed with a valid session.\n   *\n   * Unless `authRequired` is enabled, this will be simple forward.\n   *\n   * Unless a valid session exist (but required), the callback will be not invoked.\n   *\n   * @param {function} fn callback\n   * @returns {object} promise (resolved on either performed or queued)\n   */\n  ensureOpenAuthConnection(fn) {\n    if (!this.options.authRequired) {\n      // easy: no login required\n      return this.ensureOpenConnection(fn);\n    } else {\n      let fnWrapper = () => {\n        if (this.authHandler) {\n          const onValidAuth = () => {\n            this.states.authorized = true;\n            fn();\n          };\n          const onInvalidAuth = () => {\n            this.states.authorized = false;\n            if (this.options.debugEnabled) {\n              this.$log.debug('[Vert.x EB Service] Message was not sent due authHandler rejected');\n            }\n          };\n          const authResult = this.authHandler(this.eventBus);\n          if (!(authResult && angular.isFunction(authResult.then))) {\n            if (this.options.debugEnabled) {\n              this.$log.debug('[Vert.x EB Service] Message was not sent because authHandler is returning not a promise');\n            }\n            return false;\n          }\n          authResult.then(onValidAuth, onInvalidAuth);\n          return true;\n        } else {\n          // ignore this message\n          if (this.options.debugEnabled) {\n            this.$log.debug('[Vert.x EB Service] Message was not sent because no authHandler is defined');\n          }\n          return false;\n        }\n      };\n      fnWrapper.displayName = `${moduleName}.service.delegate.live.ensureOpenAuthConnection.fnWrapper`;\n      return this.ensureOpenConnection(fnWrapper);\n    }\n  }\n\n  /**\n   * Returns the current connection state. The state is being cached internally.\n   *\n   * @param {boolean=} [immediate=false] if true, the connection state will be queried directly.\n   * @returns {number} state type of vertx.EventBus\n   */\n  getConnectionState(immediate) {\n    if (this.options.enabled) {\n      if (immediate) {\n        this.connectionState = this.eventBus.state;\n      }\n    } else {\n      this.connectionState = this.eventBus.EventBus.CLOSED;\n    }\n    return this.connectionState;\n  }\n\n  /**\n   * Returns true if the current connection state ({@link knalli.angular-vertxbus.vertxEventBusService#methods_getConnectionState getConnectionState()}) is `OPEN`.\n   *\n   * @returns {boolean} connection open state\n   */\n  isConnectionOpen() {\n    return this.getConnectionState() === this.eventBus.EventBus.OPEN;\n  }\n\n  /**\n   * Returns true if the session is valid\n   *\n   * @returns {boolean} state\n   */\n  isAuthorized() {\n    return this.states.authorized;\n  }\n\n  // internal\n  isConnected() {\n    return this.states.connected;\n  }\n\n  isEnabled() {\n    return this.options.enabled;\n  }\n\n  /**\n   * Returns the current amount of messages in the internal buffer.\n   *\n   * @returns {number} amount\n   */\n  getMessageQueueLength() {\n    return this.messageQueue.size();\n  }\n\n}\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/lib/service/delegate/EventBusDelegate.js\n **/","/*\n Simple queue implementation\n\n FIFO: #push() + #first()\n LIFO: #push() + #last()\n */\nexport default class Queue {\n\n  constructor(maxSize = 10) {\n    this.maxSize = maxSize;\n    this.items = [];\n  }\n\n  push(item) {\n    this.items.push(item);\n    return this.recalibrateBufferSize();\n  }\n\n  recalibrateBufferSize() {\n    while (this.items.length > this.maxSize) {\n      this.first();\n    }\n    return this;\n  }\n\n  last() {\n    return this.items.pop();\n  }\n\n  first() {\n    return this.items.shift(0);\n  }\n\n  size() {\n    return this.items.length;\n  }\n\n}\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/lib/support/Queue.js\n **/","/*\n Simple Map implementation\n\n This implementation allows usage of non serializable keys for values.\n */\nexport default class SimpleMap {\n\n  constructor() {\n    this.clear();\n  }\n\n  // Stores the value under the key.\n  // Chainable\n  put(key, value) {\n    var idx = this._indexForKey(key);\n    if (idx > -1) {\n      this.values[idx] = value;\n    } else {\n      this.keys.push(key);\n      this.values.push(value);\n    }\n    return this;\n  }\n\n  // Returns value for key, otherwise undefined.\n  get(key) {\n    var idx = this._indexForKey(key);\n    if (idx > -1) {\n      return this.values[idx];\n    }\n  }\n\n  // Returns true if the key exists.\n  containsKey(key) {\n    let idx = this._indexForKey(key);\n    return idx > -1;\n  }\n\n  // Returns true if the value exists.\n  containsValue(value) {\n    let idx = this._indexForValue(value);\n    return idx > -1;\n  }\n\n  // Removes the key and its value.\n  remove(key) {\n    let idx = this._indexForKey(key);\n    if (idx > -1) {\n      this.keys[idx] = undefined;\n      this.values[idx] = undefined;\n    }\n\n  }\n\n  // Clears all keys and values.\n  clear() {\n    this.keys = [];\n    this.values = [];\n    return this;\n  }\n\n  // Returns index of key, otherwise -1.\n  _indexForKey(key) {\n    for (let i in this.keys) {\n      if (key === this.keys[i]) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  _indexForValue(value) {\n    for (let i in this.values) {\n      if (value === this.values[i]) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n}\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/lib/support/SimpleMap.js\n **/","export default class BaseDelegate {\n\n  observe() {}\n\n  getConnectionState() {\n    return 3; // CLOSED\n  }\n\n  isConnectionOpen() {\n    return false;\n  }\n\n  isAuthorized() {\n    return false;\n  }\n\n  isEnabled() {\n    return false;\n  }\n\n  isConnected() {\n    return false;\n  }\n\n  send() {}\n\n  publish() {}\n\n}\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/lib/service/delegate/BaseDelegate.js\n **/","import BaseDelegate from './BaseDelegate';\n\nexport default class NoopDelegate extends BaseDelegate {}\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/lib/service/delegate/NoopDelegate.js\n **/","import {moduleName} from '../../config';\n\nexport default class Delegator {\n\n  constructor(delegate, $log) {\n    this.delegate = delegate;\n    this.$log = $log;\n    this.handlers = {};\n    this.delegate.observe({\n      afterEventbusConnected: () => this.afterEventbusConnected()\n    });\n  }\n\n  afterEventbusConnected() {\n    for (let address in this.handlers) {\n      if (Object.prototype.hasOwnProperty.call(this.handlers, address)) {\n        let callbacks = this.handlers[address];\n        if (callbacks && callbacks.length) {\n          for (let {headers, callback} of callbacks) {\n            this.delegate.registerHandler(address, headers, callback);\n          }\n        }\n      }\n    }\n  }\n\n  /**\n   * @ngdoc method\n   * @module knalli.angular-vertxbus\n   * @methodOf knalli.angular-vertxbus.vertxEventBusService\n   * @name .#registerHandler\n   *\n   * @description\n   * Registers a callback handler for the specified address match.\n   *\n   * @param {string} address target address\n   * @param {object} headers optional headers\n   * @param {function} callback handler with params `(message, replyTo)`\n   * @returns {function} deconstructor\n   */\n  registerHandler(address, headers, callback) {\n    if (!this.handlers[address]) {\n      this.handlers[address] = [];\n    }\n    var handler = {headers, callback};\n    this.handlers[address].push(handler);\n    var unregisterFn = null;\n    if (this.delegate.isConnectionOpen()) {\n      this.delegate.registerHandler(address, headers, callback);\n      unregisterFn = () => this.delegate.unregisterHandler(address, headers, callback);\n    }\n    // and return the deregister callback\n    var deconstructor = () => {\n      if (unregisterFn) {\n        unregisterFn();\n        unregisterFn = undefined;\n      }\n      // Remove from internal map\n      if (this.handlers[address]) {\n        var index = this.handlers[address].indexOf(handler);\n        if (index > -1) {\n          this.handlers[address].splice(index, 1);\n        }\n        if (this.handlers[address].length < 1) {\n          this.handlers[address] = undefined;\n        }\n      }\n    };\n    deconstructor.displayName = `${moduleName}.service.registerHandler.deconstructor`;\n    return deconstructor;\n  }\n\n  /**\n   * @ngdoc method\n   * @module knalli.angular-vertxbus\n   * @methodOf knalli.angular-vertxbus.vertxEventBusService\n   * @name .#on\n   *\n   * @description\n   * See (using {@link knalli.angular-vertxbus.vertxEventBusService#methods_registerHandler registerHandler()})\n   */\n  on(address, headers, callback) {\n    return this.registerHandler(address, headers, callback);\n  }\n\n  /**\n   * @ngdoc method\n   * @module knalli.angular-vertxbus\n   * @methodOf knalli.angular-vertxbus.vertxEventBusService\n   * @name .#addListener\n   *\n   * @description\n   * See (using {@link knalli.angular-vertxbus.vertxEventBusService#methods_registerHandler registerHandler()})\n   */\n  addListener(address, headers, callback) {\n    return this.registerHandler(address, headers, callback);\n  }\n\n  /**\n   * @ngdoc method\n   * @module knalli.angular-vertxbus\n   * @methodOf knalli.angular-vertxbus.vertxEventBusService\n   * @name .#unregisterHandler\n   *\n   * @description\n   * Removes a callback handler for the specified address match.\n   *\n   * @param {string} address target address\n   * @param {object} headers optional headers\n   * @param {function} callback handler with params `(message, replyTo)`\n   */\n  unregisterHandler(address, headers, callback) {\n    // Remove from internal map\n    if (this.handlers[address]) {\n      var index = this.handlers[address].indexOf({headers, callback});\n      if (index > -1) {\n        this.handlers[address].splice(index, 1);\n      }\n      if (this.handlers[address].length < 1) {\n        this.handlers[address] = undefined;\n      }\n    }\n    // Remove from real instance\n    if (this.delegate.isConnectionOpen()) {\n      this.delegate.unregisterHandler(address, headers, callback);\n    }\n  }\n\n  /**\n   * @ngdoc method\n   * @module knalli.angular-vertxbus\n   * @methodOf knalli.angular-vertxbus.vertxEventBusService\n   * @name .#un\n   *\n   * @description\n   * See (using {@link knalli.angular-vertxbus.vertxEventBusService#methods_registerHandler unregisterHandler()})\n   */\n  un(address, headers, callback) {\n    return this.unregisterHandler(address, headers, callback);\n  }\n\n  /**\n   * @ngdoc method\n   * @module knalli.angular-vertxbus\n   * @methodOf knalli.angular-vertxbus.vertxEventBusService\n   * @name .#removeListener\n   *\n   * @description\n   * See (using {@link knalli.angular-vertxbus.vertxEventBusService#methods_registerHandler unregisterHandler()})\n   */\n  removeListener(address, headers, callback) {\n    return this.unregisterHandler(address, headers, callback);\n  }\n\n  /**\n   * @ngdoc method\n   * @module knalli.angular-vertxbus\n   * @methodOf knalli.angular-vertxbus.vertxEventBusService\n   * @name .#send\n   *\n   * @description\n   * Sends a message to the specified address (using {@link knalli.angular-vertxbus.vertxEventBus#methods_send vertxEventBus.send()}).\n   *\n   * @param {string} address target address\n   * @param {object} message payload message\n   * @param {object} headers headers\n   * @param {number=} [options.timeout=10000] (in ms) after which the promise will be rejected\n   * @param {boolean=} [options.expectReply=true] if false, the promise will be resolved directly and\n   *                                       no replyHandler will be created\n   * @returns {object} promise\n   */\n  send(address, message, headers = {}, options = {timeout: 10000, expectReply: true}) {\n    return this.delegate.send(address, message, headers, options.timeout, options.expectReply);\n  }\n\n  /**\n   * @ngdoc method\n   * @module knalli.angular-vertxbus\n   * @methodOf knalli.angular-vertxbus.vertxEventBusService\n   * @name .#publish\n   *\n   * @description\n   * Publishes a message to the specified address (using {@link knalli.angular-vertxbus.vertxEventBus#methods_publish vertxEventBus.publish()}).\n   *\n   * @param {string} address target address\n   * @param {object} message payload message\n   * @param {object=} headers headers\n   * @returns {object} promise (resolved on either performed or queued)\n   */\n  publish(address, message, headers = {}) {\n    return this.delegate.publish(address, message, headers);\n  }\n\n  /**\n   * @ngdoc method\n   * @module knalli.angular-vertxbus\n   * @methodOf knalli.angular-vertxbus.vertxEventBusService\n   * @name .#emit\n   *\n   * @description\n   * See (using {@link knalli.angular-vertxbus.vertxEventBusService#methods_publish publish()})\n   */\n  emit(address, message, headers = {}) {\n    return this.publish(address, message, headers);\n  }\n\n  /**\n   * @ngdoc method\n   * @module knalli.angular-vertxbus\n   * @methodOf knalli.angular-vertxbus.vertxEventBusService\n   * @name .#getConnectionState\n   *\n   * @description\n   * Returns the current connection state. The state is being cached internally.\n   *\n   * @returns {number} state type of vertx.EventBus\n   */\n  getConnectionState() {\n    return this.delegate.getConnectionState();\n  }\n\n  /**\n   * @ngdoc method\n   * @module knalli.angular-vertxbus\n   * @methodOf knalli.angular-vertxbus.vertxEventBusService\n   * @name .#readyState\n   *\n   * @description\n   * See (using {@link knalli.angular-vertxbus.vertxEventBusService#methods_getConnectionState getConnectionState()})\n   */\n  readyState() {\n    return this.getConnectionState();\n  }\n\n\n\n  /**\n   * @ngdoc method\n   * @module knalli.angular-vertxbus\n   * @methodOf knalli.angular-vertxbus.vertxEventBusService\n   * @name .#isConnectionOpen\n   *\n   * @description\n   * Returns true if the current connection state ({@link knalli.angular-vertxbus.vertxEventBusService#methods_getConnectionState getConnectionState()}) is `OPEN`.\n   *\n   * @returns {boolean} connection open state\n   */\n  isConnectionOpen() {\n    return this.isConnectionOpen();\n  }\n\n  /**\n   * @ngdoc method\n   * @module knalli.angular-vertxbus\n   * @methodOf knalli.angular-vertxbus.vertxEventBusService\n   * @name .#isEnabled\n   *\n   * @description\n   * Returns true if service is being enabled.\n   *\n   * @returns {boolean} state\n   */\n  isEnabled() {\n    return this.delegate.isEnabled();\n  }\n\n  /**\n   * @ngdoc method\n   * @module knalli.angular-vertxbus\n   * @methodOf knalli.angular-vertxbus.vertxEventBusService\n   * @name .#isConnected\n   *\n   * @description\n   * Returns true if service (and the eventbus) is being connected.\n   *\n   * @returns {boolean} state\n   */\n  isConnected() {\n    return this.delegate.isConnected();\n  }\n\n  /**\n   * @ngdoc method\n   * @module knalli.angular-vertxbus\n   * @methodOf knalli.angular-vertxbus.vertxEventBusService\n   * @name .#isAuthorized\n   *\n   * @description\n   * Returns true if the authorization is valid\n   *\n   * @returns {boolean} state\n   */\n  isAuthorized() {\n    return this.delegate.isAuthorized();\n  }\n\n  /**\n   * @ngdoc method\n   * @module knalli.angular-vertxbus\n   * @methodOf knalli.angular-vertxbus.vertxEventBusService\n   * @name .#isValidSession\n   *\n   * See (using {@link knalli.angular-vertxbus.vertxEventBusService#methods_isAuthorized isAuthorized()})\n   */\n  isValidSession() {\n    return this.delegate.isAuthorized();\n  }\n\n  /**\n   * @ngdoc method\n   * @module knalli.angular-vertxbus\n   * @methodOf knalli.angular-vertxbus.vertxEventBusService\n   * @name .#getMessageQueueLength\n   *\n   * @description\n   * Returns the current amount of messages in the internal buffer.\n   *\n   * @returns {number} amount\n   */\n  getMessageQueueLength() {\n    return this.delegate.getMessageQueueLength();\n  }\n\n}\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/lib/service/Delegator.js\n **/"],"sourceRoot":""}